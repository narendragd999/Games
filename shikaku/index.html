<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shikaku Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .container {
            max-width: 500px;
            width: 95%;
            height: 95vh;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            text-align: center;
        }

        h1 {
            font-size: 24px;
            color: #667eea;
            margin-bottom: 5px;
        }

        .status {
            font-size: 14px;
            color: #666;
        }

        .game-board {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .grid {
            display: inline-grid;
            gap: 0;
            background: #333;
            border: 2px solid #333;
            touch-action: none;
        }

        .cell {
            background: white;
            border: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            color: #333;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .cell.selecting {
            background: rgba(102, 126, 234, 0.3);
        }

        .cell.completed {
            background: rgba(102, 126, 234, 0.5);
            border-color: #667eea;
        }

        .cell.hint {
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0%, 100% { background: white; }
            50% { background: rgba(255, 215, 0, 0.6); }
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        button {
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        button:active {
            transform: scale(0.95);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 15px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .modal h2 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .modal p {
            margin-bottom: 10px;
            line-height: 1.6;
            color: #555;
        }

        .modal ul {
            margin-left: 20px;
            margin-bottom: 15px;
            color: #555;
        }

        .close-btn {
            background: #667eea;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¯ Shikaku Puzzle</h1>
            <div class="status">Divide the grid into rectangles!</div>
        </div>

        <div class="game-board">
            <div class="grid" id="grid"></div>
        </div>

        <div class="controls">
            <button class="btn-primary" id="newBtn">New Puzzle</button>
            <button class="btn-secondary" id="checkBtn">Check</button>
            <button class="btn-success" id="hintBtn">Hint</button>
            <button class="btn-warning" id="solveBtn">Auto-Solve</button>
            <button class="btn-primary" id="instructBtn" style="grid-column: 1 / -1;">Instructions</button>
        </div>
    </div>

    <div class="modal" id="modal">
        <div class="modal-content">
            <h2>How to Play Shikaku</h2>
            <p><strong>Goal:</strong> Divide the grid into rectangles so that each rectangle contains exactly one number, and that number equals the area of the rectangle.</p>
            
            <p><strong>Rules:</strong></p>
            <ul>
                <li>Each rectangle must contain exactly one clue number</li>
                <li>The area of each rectangle must equal its clue number</li>
                <li>All cells must be part of a rectangle</li>
                <li>Rectangles cannot overlap</li>
            </ul>
            
            <p><strong>How to Play:</strong></p>
            <ul>
                <li><strong>Desktop:</strong> Click and drag to select rectangles</li>
                <li><strong>Mobile:</strong> Touch and drag to select rectangles</li>
                <li>Click/tap a completed rectangle to remove it</li>
            </ul>
            
            <p><strong>Buttons:</strong></p>
            <ul>
                <li><strong>New Puzzle:</strong> Generate a fresh puzzle</li>
                <li><strong>Check:</strong> Verify your current solution</li>
                <li><strong>Hint:</strong> Highlight a correct rectangle</li>
                <li><strong>Auto-Solve:</strong> Show the complete solution</li>
            </ul>
            
            <button class="close-btn" id="closeBtn">Got it!</button>
        </div>
    </div>

    <script>
        (function() {
            const GRID_SIZE = 6;
            let grid = [];
            let clues = [];
            let solution = [];
            let userRectangles = [];
            let selecting = false;
            let startCell = null;
            let currentSelection = [];
            
            let audioCtx = null;

            function initAudio() {
                if (!audioCtx) {
                    try {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        audioCtx = new AudioContext();
                    } catch(e) {
                        console.log('Audio not supported');
                    }
                }
            }

            function playSound(frequency, duration) {
                try {
                    initAudio();
                    if (!audioCtx) return;
                    if (audioCtx.state === 'suspended') {
                        audioCtx.resume();
                    }
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.value = frequency;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                    osc.start();
                    osc.stop(audioCtx.currentTime + duration);
                } catch (e) {
                    // Silent fail
                }
            }

            function generatePuzzle() {
                grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
                clues = [];
                solution = [];
                userRectangles = [];
                
                const used = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
                
                while (solution.length < 8) {
                    const row = Math.floor(Math.random() * GRID_SIZE);
                    const col = Math.floor(Math.random() * GRID_SIZE);
                    
                    if (used[row][col]) continue;
                    
                    const maxWidth = GRID_SIZE - col;
                    const maxHeight = GRID_SIZE - row;
                    
                    let validSizes = [];
                    for (let w = 1; w <= Math.min(maxWidth, 4); w++) {
                        for (let h = 1; h <= Math.min(maxHeight, 4); h++) {
                            if (w * h >= 2 && w * h <= 6) {
                                let valid = true;
                                for (let r = row; r < row + h && valid; r++) {
                                    for (let c = col; c < col + w && valid; c++) {
                                        if (used[r][c]) valid = false;
                                    }
                                }
                                if (valid) validSizes.push({w, h});
                            }
                        }
                    }
                    
                    if (validSizes.length === 0) continue;
                    
                    const size = validSizes[Math.floor(Math.random() * validSizes.length)];
                    const rect = {
                        row: row,
                        col: col,
                        width: size.w,
                        height: size.h,
                        area: size.w * size.h
                    };
                    
                    for (let r = row; r < row + size.h; r++) {
                        for (let c = col; c < col + size.w; c++) {
                            used[r][c] = true;
                        }
                    }
                    
                    solution.push(rect);
                    clues.push({
                        row: row,
                        col: col,
                        value: rect.area
                    });
                }
                
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (!used[row][col]) {
                            const rect = {row, col, width: 1, height: 1, area: 1};
                            solution.push(rect);
                            clues.push({row, col, value: 1});
                            used[row][col] = true;
                        }
                    }
                }
                
                for (let i = 0; i < clues.length; i++) {
                    const clue = clues[i];
                    grid[clue.row][clue.col] = clue.value;
                }
            }

            function renderGrid() {
                const gridEl = document.getElementById('grid');
                gridEl.innerHTML = '';
                
                const containerWidth = gridEl.parentElement.offsetWidth - 30;
                const containerHeight = gridEl.parentElement.offsetHeight - 30;
                const cellSize = Math.min(
                    Math.floor(containerWidth / GRID_SIZE),
                    Math.floor(containerHeight / GRID_SIZE),
                    60
                );
                
                gridEl.style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${cellSize}px)`;
                
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.style.width = cellSize + 'px';
                        cell.style.height = cellSize + 'px';
                        cell.style.fontSize = Math.floor(cellSize * 0.4) + 'px';
                        
                        if (grid[row][col] > 0) {
                            cell.textContent = grid[row][col];
                        }
                        
                        const rect = userRectangles.find(r => 
                            row >= r.row && row < r.row + r.height &&
                            col >= r.col && col < r.col + r.width
                        );
                        if (rect) {
                            cell.classList.add('completed');
                        }
                        
                        cell.addEventListener('mousedown', handleMouseDown);
                        cell.addEventListener('mouseenter', handleMouseEnter);
                        cell.addEventListener('touchstart', handleTouchStart, {passive: false});
                        cell.addEventListener('touchmove', handleTouchMove, {passive: false});
                        
                        gridEl.appendChild(cell);
                    }
                }
            }

            function handleMouseDown(e) {
                e.preventDefault();
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                
                const existing = userRectangles.findIndex(r => 
                    row >= r.row && row < r.row + r.height &&
                    col >= r.col && col < r.col + r.width
                );
                
                if (existing !== -1) {
                    userRectangles.splice(existing, 1);
                    playSound(300, 0.1);
                    renderGrid();
                    return;
                }
                
                selecting = true;
                startCell = {row, col};
                currentSelection = [{row, col}];
                updateSelection();
            }

            function handleMouseEnter(e) {
                if (!selecting) return;
                
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                
                const minRow = Math.min(startCell.row, row);
                const maxRow = Math.max(startCell.row, row);
                const minCol = Math.min(startCell.col, col);
                const maxCol = Math.max(startCell.col, col);
                
                currentSelection = [];
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        currentSelection.push({row: r, col: c});
                    }
                }
                updateSelection();
            }

            function handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const el = document.elementFromPoint(touch.clientX, touch.clientY);
                if (el && el.classList.contains('cell')) {
                    handleMouseDown({target: el, preventDefault: () => {}});
                }
            }

            function handleTouchMove(e) {
                e.preventDefault();
                if (!selecting) return;
                const touch = e.touches[0];
                const el = document.elementFromPoint(touch.clientX, touch.clientY);
                if (el && el.classList.contains('cell')) {
                    handleMouseEnter({target: el});
                }
            }

            function updateSelection() {
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('selecting');
                });
                
                currentSelection.forEach(({row, col}) => {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('selecting');
                });
            }

            function finishSelection() {
                if (!selecting) return;
                selecting = false;
                
                if (currentSelection.length > 0) {
                    const minRow = Math.min(...currentSelection.map(c => c.row));
                    const maxRow = Math.max(...currentSelection.map(c => c.row));
                    const minCol = Math.min(...currentSelection.map(c => c.col));
                    const maxCol = Math.max(...currentSelection.map(c => c.col));
                    
                    const rect = {
                        row: minRow,
                        col: minCol,
                        width: maxCol - minCol + 1,
                        height: maxRow - minRow + 1
                    };
                    
                    let hasClue = false;
                    for (let r = minRow; r <= maxRow; r++) {
                        for (let c = minCol; c <= maxCol; c++) {
                            if (grid[r][c] > 0) hasClue = true;
                        }
                    }
                    
                    if (hasClue) {
                        userRectangles.push(rect);
                        playSound(440, 0.1);
                    }
                }
                
                currentSelection = [];
                renderGrid();
            }

            function checkSolution() {
                console.log('Check button clicked');
                const covered = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
                let correct = true;
                
                for (const rect of userRectangles) {
                    let clueCount = 0;
                    let clueValue = 0;
                    
                    for (let r = rect.row; r < rect.row + rect.height; r++) {
                        for (let c = rect.col; c < rect.col + rect.width; c++) {
                            if (covered[r][c]) {
                                correct = false;
                                break;
                            }
                            covered[r][c] = true;
                            if (grid[r][c] > 0) {
                                clueCount++;
                                clueValue = grid[r][c];
                            }
                        }
                    }
                    
                    if (clueCount !== 1 || rect.width * rect.height !== clueValue) {
                        correct = false;
                    }
                }
                
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (!covered[r][c]) correct = false;
                    }
                }
                
                if (correct) {
                    playSound(523, 0.15);
                    setTimeout(() => playSound(659, 0.15), 150);
                    setTimeout(() => playSound(784, 0.2), 300);
                    alert('ðŸŽ‰ Congratulations! You solved it!');
                } else {
                    playSound(200, 0.2);
                    alert('âŒ Not quite right. Keep trying!');
                }
            }

            function getHint() {
                console.log('Hint button clicked');
                for (const rect of solution) {
                    const exists = userRectangles.some(r => 
                        r.row === rect.row && r.col === rect.col &&
                        r.width === rect.width && r.height === rect.height
                    );
                    
                    if (!exists) {
                        for (let r = rect.row; r < rect.row + rect.height; r++) {
                            for (let c = rect.col; c < rect.col + rect.width; c++) {
                                const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                                if (cell) cell.classList.add('hint');
                            }
                        }
                        
                        playSound(600, 0.1);
                        
                        setTimeout(() => {
                            document.querySelectorAll('.hint').forEach(c => c.classList.remove('hint'));
                        }, 500);
                        return;
                    }
                }
                
                alert('ðŸ’¡ All rectangles are already placed correctly!');
            }

            function autoSolve() {
                console.log('Auto-solve button clicked');
                userRectangles = JSON.parse(JSON.stringify(solution));
                playSound(523, 0.1);
                setTimeout(() => playSound(659, 0.1), 100);
                renderGrid();
            }

            function newPuzzle() {
                console.log('New puzzle button clicked');
                generatePuzzle();
                renderGrid();
                playSound(440, 0.1);
            }

            function showInstructions() {
                console.log('Instructions button clicked');
                document.getElementById('modal').classList.add('active');
                playSound(523, 0.1);
            }

            function closeInstructions() {
                console.log('Close button clicked');
                document.getElementById('modal').classList.remove('active');
                playSound(440, 0.1);
            }

            document.addEventListener('mouseup', finishSelection);
            document.addEventListener('touchend', finishSelection);

            // Wait for DOM to be fully loaded
            window.addEventListener('DOMContentLoaded', function() {
                // Event Listeners
                const newBtn = document.getElementById('newBtn');
                const checkBtn = document.getElementById('checkBtn');
                const hintBtn = document.getElementById('hintBtn');
                const solveBtn = document.getElementById('solveBtn');
                const instructBtn = document.getElementById('instructBtn');
                const closeBtn = document.getElementById('closeBtn');
                const modal = document.getElementById('modal');

                if (newBtn) newBtn.addEventListener('click', newPuzzle);
                if (checkBtn) checkBtn.addEventListener('click', checkSolution);
                if (hintBtn) hintBtn.addEventListener('click', getHint);
                if (solveBtn) solveBtn.addEventListener('click', autoSolve);
                if (instructBtn) instructBtn.addEventListener('click', showInstructions);
                if (closeBtn) closeBtn.addEventListener('click', closeInstructions);
                
                if (modal) {
                    modal.addEventListener('click', (e) => {
                        if (e.target.id === 'modal') closeInstructions();
                    });
                }

                // Initialize
                generatePuzzle();
                renderGrid();
            });
        })();
    </script>
</body>
</html>