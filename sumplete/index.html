<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sumplete: Infinite Logic</title>
    <style>
        :root {
            --bg-grad: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --glass: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --text-main: #ffffff;
            --text-muted: #a0a0a0;
            --accent: #e94560;
            --success: #4cc9f0;
            --cell-bg: rgba(255, 255, 255, 0.15);
            --cell-deleted: rgba(0, 0, 0, 0.4);
            --cell-selected: rgba(76, 201, 240, 0.2);
            --target-ok: #4cc9f0;
            --target-wrong: #e94560;
            --font-main: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-grad);
            font-family: var(--font-main);
            color: var(--text-main);
            height: 100dvh;
            overflow: hidden; /* No scrolling */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* --- Layout --- */
        #app-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            max-width: 600px;
            position: relative;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header-controls button {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .header-controls button:active {
            transform: scale(0.9);
            background: rgba(255,255,255,0.2);
        }

        /* --- Game Board Area --- */
        #game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            margin-bottom: 10px;
        }

        /* The Grid Layout */
        #grid-wrapper {
            display: grid;
            gap: 6px;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 12px;
            /* Grid template defined in JS based on size */
        }

        .cell {
            width: 45px;
            height: 45px;
            background: var(--cell-bg);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255,255,255,0.05);
        }

        @media (min-width: 400px) {
            .cell { width: 55px; height: 55px; font-size: 1.4rem; }
        }

        /* Cell States */
        .cell.deleted {
            background: var(--cell-deleted);
            color: var(--text-muted);
            opacity: 0.6;
            transform: scale(0.9);
            text-decoration: line-through;
        }

        .cell.active {
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Targets */
        .target {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--text-muted);
            background: transparent;
        }

        .target.correct { color: var(--target-ok); text-shadow: 0 0 8px var(--target-ok); }
        .target.wrong { color: var(--target-wrong); }

        /* --- Controls --- */
        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding-bottom: 10px;
        }

        .btn {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: white;
            padding: 12px;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            transition: background 0.2s, transform 0.1s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:active { transform: scale(0.96); }
        .btn-primary { background: var(--accent); border: none; }
        .btn-secondary { background: rgba(255,255,255,0.1); }

        /* --- Modals & Overlays --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.open {
            opacity: 1;
            pointer-events: all;
        }

        .modal {
            background: #1e293b;
            width: 90%;
            max-width: 400px;
            border-radius: 16px;
            padding: 24px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            transform: translateY(20px);
            transition: transform 0.3s;
            text-align: center;
        }

        .modal-overlay.open .modal {
            transform: translateY(0);
        }

        .modal h2 { margin-top: 0; color: var(--success); }
        .modal p { color: #cbd5e1; line-height: 1.5; }
        
        .close-modal {
            margin-top: 20px;
            width: 100%;
        }

        /* --- Toast Notification --- */
        #toast {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: rgba(255,255,255,0.95);
            color: #1a1a2e;
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: 600;
            font-size: 0.9rem;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3);
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            z-index: 200;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* SVG Icons */
        .icon { width: 20px; height: 20px; fill: currentColor; }

    </style>
</head>
<body>

    <div id="toast">Message</div>

    <div id="app-container">
        <header>
            <h1>Sumplete</h1>
            <div class="header-controls">
                <button id="btn-instructions" aria-label="Instructions">
                    <!-- Help Icon -->
                    <svg class="icon" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/></svg>
                </button>
            </div>
        </header>

        <div id="game-area">
            <div id="grid-wrapper">
                <!-- Grid generated by JS -->
            </div>
        </div>

        <div id="controls">
            <button class="btn btn-secondary" id="btn-new">
                <svg class="icon" viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                New
            </button>
            <button class="btn btn-primary" id="btn-check">
                <svg class="icon" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
                Check
            </button>
            <button class="btn btn-secondary" id="btn-solve">
                <svg class="icon" viewBox="0 0 24 24"><path d="M19.8 18.4L14 10.67V6.5l1.35-1.69c.26-.33.03-.81-.39-.81H9.04c-.42 0-.65.48-.39.81L10 6.5v4.17L4.2 18.4c-.49.66-.02 1.6.8 1.6h14c.82 0 1.29-.94.8-1.6z"/></svg>
                Solve
            </button>
            <button class="btn btn-secondary" id="btn-hint">
                <svg class="icon" viewBox="0 0 24 24"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/></svg>
                Hint
            </button>
        </div>
    </div>

    <!-- Win/Instructions Modal -->
    <div id="modal-overlay" class="modal-overlay">
        <div class="modal">
            <h2 id="modal-title">How to Play</h2>
            <div id="modal-content">
                <p><strong>Goal:</strong> Delete numbers so that the sum of the remaining numbers in each row and column matches the target numbers.</p>
                <p>1. Tap a number to toggle it (Keep/Delete).</p>
                <p>2. Row targets are on the right. Column targets are at the bottom.</p>
                <p>3. Blue text means the sum is correct. Red means incorrect.</p>
            </div>
            <button class="btn btn-primary close-modal" id="btn-modal-close">Got it</button>
        </div>
    </div>

<script>
/**
 * Game Logic & State Management
 */
const GameState = {
    gridSize: 5, // 5x5 is standard for quick mobile play
    grid: [], // Values
    deleted: [], // Boolean matrix
    rowTargets: [],
    colTargets: [],
    solutionMap: [], // Stores the "true" solution for generation
    isAnimating: false
};

// DOM Elements
const gridWrapper = document.getElementById('grid-wrapper');
const btnNew = document.getElementById('btn-new');
const btnCheck = document.getElementById('btn-check');
const btnSolve = document.getElementById('btn-solve');
const btnHint = document.getElementById('btn-hint');
const btnInstructions = document.getElementById('btn-instructions');
const toastEl = document.getElementById('toast');
const modalOverlay = document.getElementById('modal-overlay');
const modalTitle = document.getElementById('modal-title');
const modalContent = document.getElementById('modal-content');
const btnModalClose = document.getElementById('btn-modal-close');

// Audio Context
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx = new AudioContext();

/**
 * Sound Engine
 */
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    const now = audioCtx.currentTime;

    if (type === 'tap') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'delete') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
    } else if (type === 'win') {
        osc.type = 'triangle';
        // Arpeggio
        [440, 554, 659, 880].forEach((freq, i) => {
            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();
            osc2.connect(gain2);
            gain2.connect(audioCtx.destination);
            osc2.type = 'sine';
            osc2.frequency.value = freq;
            gain2.gain.setValueAtTime(0.2, now + i*0.1);
            gain2.gain.linearRampToValueAtTime(0, now + i*0.1 + 0.3);
            osc2.start(now + i*0.1);
            osc2.stop(now + i*0.1 + 0.3);
        });
    } else if (type === 'error') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.3);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    }
}

/**
 * Game Generation Logic
 */
function initGame() {
    // 1. Initialize Grid with random numbers (1-9)
    GameState.grid = [];
    for (let r = 0; r < GameState.gridSize; r++) {
        const row = [];
        for (let c = 0; c < GameState.gridSize; c++) {
            row.push(Math.floor(Math.random() * 9) + 1);
        }
        GameState.grid.push(row);
    }

    // 2. Generate a random "Solution" (which cells to keep)
    // We ensure at least one number is kept per row/col to avoid boring puzzles
    GameState.solutionMap = [];
    GameState.deleted = []; // Start with all false (kept)
    
    for (let r = 0; r < GameState.gridSize; r++) {
        const rowSol = [];
        const rowDel = [];
        for (let c = 0; c < GameState.gridSize; c++) {
            // 60% chance to keep a number
            const keep = Math.random() < 0.6;
            rowSol.push(keep);
            rowDel.push(false); // Player starts with everything shown
        }
        GameState.solutionMap.push(rowSol);
        GameState.deleted.push(rowDel);
    }

    // Calculate Targets based on Solution
    GameState.rowTargets = GameState.solutionMap.map((row, rIdx) => {
        let sum = 0;
        row.forEach((keep, cIdx) => {
            if (keep) sum += GameState.grid[rIdx][cIdx];
        });
        return sum;
    });

    GameState.colTargets = [];
    for (let c = 0; c < GameState.gridSize; c++) {
        let sum = 0;
        for (let r = 0; r < GameState.gridSize; r++) {
            if (GameState.solutionMap[r][c]) sum += GameState.grid[r][c];
        }
        GameState.colTargets.push(sum);
    }

    renderGrid();
    showToast('New Puzzle Generated');
}

/**
 * Rendering
 */
function renderGrid() {
    gridWrapper.innerHTML = '';
    
    // CSS Grid Setup: 1 col for target, N cols for grid, 1 extra row for col targets
    // Actually simpler: 
    // Grid cells are centered. We can put Row Targets in a separate column in the grid
    // And Col Targets in a separate row.
    
    gridWrapper.style.gridTemplateColumns = `repeat(${GameState.gridSize}, 1fr) 40px`;
    gridWrapper.style.gridTemplateRows = `repeat(${GameState.gridSize}, 1fr) 40px`;

    // Render Cells & Row Targets
    for (let r = 0; r < GameState.gridSize; r++) {
        for (let c = 0; c < GameState.gridSize; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            if (GameState.deleted[r][c]) cell.classList.add('deleted');
            cell.textContent = GameState.grid[r][c];
            cell.dataset.r = r;
            cell.dataset.c = c;
            cell.onclick = () => toggleCell(r, c);
            gridWrapper.appendChild(cell);
        }
        // Row Target
        const target = document.createElement('div');
        target.className = 'target row-target';
        target.textContent = GameState.rowTargets[r];
        target.id = `rt-${r}`;
        // Position in grid
        target.style.gridColumn = GameState.gridSize + 1;
        target.style.gridRow = r + 1;
        gridWrapper.appendChild(target);
    }

    // Render Col Targets
    for (let c = 0; c < GameState.gridSize; c++) {
        const target = document.createElement('div');
        target.className = 'target col-target';
        target.textContent = GameState.colTargets[c];
        target.id = `ct-${c}`;
        target.style.gridColumn = c + 1;
        target.style.gridRow = GameState.gridSize + 1;
        gridWrapper.appendChild(target);
    }
}

function updateTargetVisuals(showErrors = false) {
    // Calculate current sums
    let allCorrect = true;

    // Rows
    GameState.rowTargets.forEach((target, r) => {
        let currentSum = 0;
        for(let c=0; c<GameState.gridSize; c++) {
            if(!GameState.deleted[r][c]) currentSum += GameState.grid[r][c];
        }
        const el = document.getElementById(`rt-${r}`);
        if (currentSum === target) {
            el.classList.add('correct');
            el.classList.remove('wrong');
        } else {
            allCorrect = false;
            el.classList.remove('correct');
            if (showErrors) el.classList.add('wrong');
            else el.classList.remove('wrong');
        }
        el.textContent = `${target} (${currentSum})`;
    });

    // Cols
    GameState.colTargets.forEach((target, c) => {
        let currentSum = 0;
        for(let r=0; r<GameState.gridSize; r++) {
            if(!GameState.deleted[r][c]) currentSum += GameState.grid[r][c];
        }
        const el = document.getElementById(`ct-${c}`);
        if (currentSum === target) {
            el.classList.add('correct');
            el.classList.remove('wrong');
        } else {
            allCorrect = false;
            el.classList.remove('correct');
            if (showErrors) el.classList.add('wrong');
            else el.classList.remove('wrong');
        }
        el.textContent = `${target} (${currentSum})`;
    });

    return allCorrect;
}

/**
 * Interactions
 */
function toggleCell(r, c) {
    if(GameState.isAnimating) return;
    GameState.deleted[r][c] = !GameState.deleted[r][c];
    playSound(GameState.deleted[r][c] ? 'delete' : 'tap');
    
    // Re-render specific cell style for performance
    const cells = gridWrapper.querySelectorAll('.cell');
    // Grid index: r * size + c
    const index = r * GameState.gridSize + c;
    const cellEl = cells[index];
    
    if (GameState.deleted[r][c]) cellEl.classList.add('deleted');
    else cellEl.classList.remove('deleted');

    updateTargetVisuals();
}

/**
 * Core Game Features
 */
function checkSolution() {
    const isWin = updateTargetVisuals(true);
    
    if (isWin) {
        playSound('win');
        showModal("Solved!", "Great job! All rows and columns match the targets.");
    } else {
        playSound('error');
        showToast("Not quite there yet.");
    }
}

function solveGame() {
    // We know the solution from generation. 
    // Logic: deleted[r][c] should be !solutionMap[r][c]
    
    GameState.isAnimating = true;
    let delay = 0;
    
    // Clear user state first? Or just transition? Let's transition.
    
    for(let r=0; r<GameState.gridSize; r++) {
        for(let c=0; c<GameState.gridSize; c++) {
            const shouldBeDeleted = !GameState.solutionMap[r][c];
            
            if(GameState.deleted[r][c] !== shouldBeDeleted) {
                setTimeout(() => {
                    GameState.deleted[r][c] = shouldBeDeleted;
                    const cells = gridWrapper.querySelectorAll('.cell');
                    const idx = r * GameState.gridSize + c;
                    if (shouldBeDeleted) cells[idx].classList.add('deleted');
                    else cells[idx].classList.remove('deleted');
                    playSound('tap');
                }, delay);
                delay += 50;
            }
        }
    }

    setTimeout(() => {
        updateTargetVisuals(true);
        GameState.isAnimating = false;
        showToast("Auto-Solved");
    }, delay + 200);
}

function provideHint() {
    // Find a cell where current state != solution state
    const mistakes = [];
    for(let r=0; r<GameState.gridSize; r++) {
        for(let c=0; c<GameState.gridSize; c++) {
            const isDeleted = GameState.deleted[r][c];
            const shouldBeDeleted = !GameState.solutionMap[r][c];
            if(isDeleted !== shouldBeDeleted) {
                mistakes.push({r, c, correctState: !shouldBeDeleted});
            }
        }
    }

    if(mistakes.length === 0) {
        showToast("Puzzle already solved!");
        updateTargetVisuals(true);
        return;
    }

    // Pick random mistake
    const hint = mistakes[Math.floor(Math.random() * mistakes.length)];
    
    // Visual feedback for hint cell
    const cells = gridWrapper.querySelectorAll('.cell');
    const idx = hint.r * GameState.gridSize + hint.c;
    const cell = cells[idx];
    
    cell.style.backgroundColor = '#e94560'; // Flash red/white
    setTimeout(() => {
        cell.style.backgroundColor = '';
        toggleCell(hint.r, hint.c); // Apply the fix
    }, 300);

    playSound('tap');
    showToast("Fixed one cell");
}

/**
 * UI Helpers
 */
function showToast(msg) {
    toastEl.textContent = msg;
    toastEl.classList.add('visible');
    setTimeout(() => {
        toastEl.classList.remove('visible');
    }, 2000);
}

function showModal(title, contentHTML) {
    modalTitle.textContent = title;
    modalContent.innerHTML = `<p>${contentHTML}</p>`;
    modalOverlay.classList.add('open');
}

// Event Listeners
btnNew.addEventListener('click', () => {
    initGame();
    btnNew.blur();
});

btnCheck.addEventListener('click', () => {
    checkSolution();
    btnCheck.blur();
});

btnSolve.addEventListener('click', () => {
    solveGame();
    btnSolve.blur();
});

btnHint.addEventListener('click', () => {
    provideHint();
    btnHint.blur();
});

btnInstructions.addEventListener('click', () => {
    showModal("How to Play", 
    `<strong>Goal:</strong> Delete numbers so that the sum of the remaining numbers in each row and column matches the target numbers.<br><br>
     1. Tap a number to toggle it (Keep/Delete).<br>
     2. Row targets are on the right. Column targets are at the bottom.<br>
     3. Blue text means the sum is correct. Red means incorrect.`);
});

btnModalClose.addEventListener('click', () => {
    modalOverlay.classList.remove('open');
});

// Close modal on outside click
modalOverlay.addEventListener('click', (e) => {
    if(e.target === modalOverlay) modalOverlay.classList.remove('open');
});

// Start Game
window.onload = () => {
    // Initialize Audio Context on first interaction if needed, 
    // but modern browsers allow creating it, just not starting it.
    initGame();
    
    // Show instructions on first load
    setTimeout(() => {
        showModal("Welcome to Sumplete", 
        `Delete numbers to match the targets.<br><br>
        Rows sum to the target on the right.<br>
        Columns sum to the target below.`);
    }, 500);
};

</script>
</body>
</html>