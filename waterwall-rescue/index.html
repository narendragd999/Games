<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡§ú‡§≤ ‡§≠‡§ø‡§§‡•ç‡§§‡§ø ‡§¨‡§ö‡§æ‡§µ: ‡§™‡•á‡§∂‡•á‡§µ‡§∞ ‡§∏‡§Ç‡§∏‡•ç‡§ï‡§∞‡§£</title>
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Variables for a sleek, dark theme */
        :root {
            --primary-color: #4CAF50; /* Green - Safe/Go */
            --danger-color: #E74C3C; /* Red - Danger/Stop */
            --accent-color: #00BCD4; /* Cyan - Highlight/Water */
            --dark-bg: #1A1A2E; /* Deep Blue/Purple for background */
            --card-bg: #2C384A; /* Darker card background */
            --text-light: #F0F4F8;
            --gem-shadow: rgba(0, 0, 0, 0.4);
            --gold: #FFD700;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }

        body {
            /* Deep, dark gradient for a professional, tech/depth feel */
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--text-light);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--card-bg);
            border-radius: 1.5rem;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5), 0 0 0 5px rgba(0, 188, 212, 0.3); /* Tech glow */
            padding: 2rem;
            max-width: 550px;
            width: 100%;
        }

        /* --- Stats Panel Styling --- */
        .stats-item {
            background-color: #1A222F; /* Very dark background for clarity */
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            box-shadow: inset 0 0 10px rgba(0, 188, 212, 0.1);
        }

        /* --- Match 3 Grid Styling --- */
        .grid-container {
            display: grid;
            gap: 4px; /* Increased gap for better separation */
            border: 5px solid var(--accent-color);
            border-radius: 0.75rem;
            box-shadow: 0 0 15px var(--accent-color); /* Neon glow on the grid */
            background-color: #000;
            padding: 5px;
        }

        .gem {
            width: 55px; /* Slightly larger gems for better touch targets */
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 32px; /* Larger emojis */
            transition: transform 0.1s ease, box-shadow 0.2s, opacity 0.1s;
            border-radius: 10px;
            user-select: none;
            box-shadow: 0 3px 6px var(--gem-shadow);
            position: relative;
        }
        
        /* Professional Gem Colors (Richer tones) */
        .gem[data-type="0"] { background-color: #C0392B; } /* Red */
        .gem[data-type="1"] { background-color: #27AE60; } /* Green */
        .gem[data-type="2"] { background-color: #2980B9; } /* Blue */
        .gem[data-type="3"] { background-color: #F39C12; } /* Yellow/Orange */
        .gem[data-type="4"] { background-color: #8E44AD; } /* Purple */

        .gem-selected {
            transform: scale(0.9); /* Invert scale to show selection */
            border: 4px solid var(--gold);
            box-shadow: 0 0 25px var(--gold); /* Gold glow */
            z-index: 10;
        }

        .gem-remove {
            opacity: 0;
            transform: scale(0.3);
        }

        /* --- Pressure Bar Styling --- */
        .pressure-bar-container {
            position: relative;
            width: 100%;
            height: 40px; /* Taller bar */
            margin-bottom: 25px;
            border-radius: 20px;
            background-color: #0d121c; /* Frame color */
            border: 3px solid var(--accent-color);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.7), 0 0 10px var(--accent-color);
            overflow: hidden;
        }

        #pressure-level {
            height: 100%;
            /* Gradient from light blue (safe) to deep blue (pressure) */
            background: linear-gradient(90deg, #1e90ff, #005f99);
            transition: width 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smooth animation */
            position: absolute;
            left: 0;
            z-index: 1;
        }
        
        /* Base styles for character and monster to align them visually */
        .game-entity {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 35px; /* Slightly larger entities */
            height: 35px;
            border: 2px solid var(--text-light);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: left 0.3s ease-out;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); /* Entity glow */
        }

        #character {
            background-color: var(--primary-color);
            z-index: 4;
        }

        #monster {
            background-color: var(--danger-color); 
            z-index: 3;
        }

        /* --- Modal Styles --- */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .modal-content {
            background-color: #1A222F; /* Dark modal background */
            padding: 40px;
            border-radius: 1.5rem;
            text-align: center;
            max-width: 90%;
            width: 450px;
            box-shadow: 0 0 30px var(--danger-color);
            border: 2px solid var(--danger-color);
        }

    </style>
</head>
<body>

    <div class="game-container">
        <h1 class="text-4xl font-extrabold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-cyan-400 tracking-wider">
            ‡§ú‡§≤ ‡§≠‡§ø‡§§‡•ç‡§§‡§ø ‡§¨‡§ö‡§æ‡§µ
        </h1>

        <!-- Score and Control Panel -->
        <div class="w-full flex justify-between items-center mb-6 p-2 rounded-xl shadow-lg border border-gray-700 bg-gray-900/50">
            <div class="stats-item">
                <div class="text-sm text-gray-400">‡§∏‡•ç‡§ï‡•ã‡§∞</div>
                <div id="score" class="text-2xl font-bold text-yellow-400">0</div>
            </div>
            <div class="stats-item">
                <div class="text-sm text-gray-400">‡§∏‡§Ç‡§ï‡•á‡§§</div>
                <div id="hints" class="text-2xl font-bold text-green-400">3</div>
            </div>
            <div class="stats-item">
                <div class="text-sm text-gray-400">‡§∏‡§Æ‡§Ø</div>
                <div id="game-time" class="text-2xl font-bold text-purple-400">0s</div>
            </div>
            <div class="flex">
                <button id="pause-btn" onclick="togglePause()" class="p-3 mx-1 text-xl bg-yellow-600 rounded-full hover:bg-yellow-500 transition-transform duration-200 transform hover:scale-105 shadow-md">‚è∏Ô∏è</button>
                <button id="sound-btn" onclick="toggleSound()" class="p-3 mx-1 text-xl bg-green-600 rounded-full hover:bg-green-500 transition-transform duration-200 transform hover:scale-105 shadow-md">üîä</button>
            </div>
        </div>

        <!-- Water Pressure / Character / Monster Visuals -->
        <div class="w-full">
            <p class="text-sm text-gray-400 mb-2 font-medium">‡§¶‡§¨‡§æ‡§µ ‡§∏‡•Ç‡§ö‡§ï (Pressure Gauge): ‡§¨‡§ö‡§æ‡§µ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§¨‡§æ‡§à‡§Ç ‡§ì‡§∞ ‡§∞‡§π‡•á‡§Ç‡•§</p>
            <div class="pressure-bar-container">
                <div id="pressure-level" style="width: 2%"></div>
                <div id="character" class="game-entity" style="left: 2%">ü¶∏</div> <!-- Char: Hero -->
                <div id="monster" class="game-entity" style="left: 98%">üëπ</div> <!-- Monster -->
            </div>
        </div>
        
        <!-- Match 3 Grid -->
        <div id="game-grid" class="grid-container">
            <!-- Gems will be inserted here by JavaScript -->
        </div>

        <!-- Game Buttons -->
        <div class="w-full mt-6 space-y-3">
            <button id="hint-btn" onclick="useHint()" class="w-full p-4 text-lg font-extrabold text-white rounded-xl bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 transition-all shadow-xl shadow-indigo-600/50">
                ‡§∏‡§Ç‡§ï‡•á‡§§ ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç (Use Hint)
            </button>
            <button id="restart-btn" onclick="init()" class="w-full p-4 text-lg font-extrabold text-white rounded-xl bg-gray-700 hover:bg-gray-600 transition-colors shadow-md">
                ‡§™‡•Å‡§®‡§É ‡§Ü‡§∞‡§Ç‡§≠ ‡§ï‡§∞‡•á‡§Ç (Restart Game)
            </button>
        </div>
    </div>

    <!-- Modals -->

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-5xl font-extrabold text-red-500 mb-4 tracking-widest">‡§ñ‡•á‡§≤ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§!</h2>
            <p class="text-xl text-gray-300 mb-4">‡§Æ‡•â‡§®‡•ç‡§∏‡•ç‡§ü‡§∞ ‡§Ü‡§™ ‡§§‡§ï ‡§™‡§π‡•Å‡§Å‡§ö ‡§ó‡§Ø‡§æ ‡§Ø‡§æ ‡§¶‡§¨‡§æ‡§µ ‡§®‡•á ‡§Ü‡§™‡§ï‡•ã ‡§ï‡•Å‡§ö‡§≤ ‡§¶‡§ø‡§Ø‡§æ!</p>
            <p class="text-3xl font-bold mb-8 text-yellow-400">‡§Ü‡§™‡§ï‡§æ ‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§∏‡•ç‡§ï‡•ã‡§∞: <span id="final-score">0</span></p>
            <button onclick="init()" class="px-8 py-4 text-xl bg-red-600 text-white font-bold rounded-xl hover:bg-red-700 transition-all shadow-lg shadow-red-600/50">‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç</button>
        </div>
    </div>

    <!-- Pause Modal -->
    <div id="pause-modal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-5xl font-extrabold text-yellow-500 mb-4 tracking-widest">‡§∞‡•ã‡§ï‡§æ ‡§ó‡§Ø‡§æ</h2>
            <p class="text-xl text-gray-300 mb-6">‡§™‡§π‡•á‡§≤‡•Ä ‡§ï‡•ã ‡§∞‡•ã‡§ï‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§¶‡§¨‡§æ‡§è‡§Å‡•§</p>
            <button onclick="togglePause()" class="px-8 py-4 text-xl bg-yellow-600 text-white font-bold rounded-xl hover:bg-yellow-700 transition-colors shadow-lg shadow-yellow-600/50">‡§ñ‡•á‡§≤ ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡•á‡§Ç</button>
        </div>
    </div>

    <!-- Message Box (Replacing alert) -->
    <div id="message-box" class="fixed top-5 right-5 z-50 p-4 bg-cyan-600 text-white rounded-lg shadow-xl transition-opacity duration-300 opacity-0 hidden font-semibold">
        ‡§Ø‡§π ‡§è‡§ï ‡§∏‡§Ç‡§ï‡•á‡§§ ‡§π‡•à!
    </div>

    <script>
        // Global Constants
        const ROWS = 8;
        const COLS = 8;
        const GEM_TYPES = ['üî¥', 'üü¢', 'üîµ', 'üü°', 'üü£']; // Emojis
        const GEM_COLORS = ['#C0392B', '#27AE60', '#2980B9', '#F39C12', '#8E44AD']; // Corresponding rich colors

        // Game State
        let gameState = {
            board: [],
            score: 0,
            hints: 3,
            isPaused: false,
            isGameOver: false,
            selectedGem: null,
            isProcessing: false, // Prevents multiple swaps/matches
            lastTime: 0,
            gameStartTime: 0,
            
            // Pressure and Monster Mechanics
            waterLevel: 2, // 0 to 100%
            pressureRate: 0.8, // % increase per second
            drainAmount: 10, // % reduction per successful match
            characterX: 2, // 0 to 100% position in the bar
            monsterX: 98, // 0 to 100% position in the bar
            monsterSpeed: 0.05, // % movement per second towards character
            soundEnabled: true,
        };

        // DOM Elements
        const gameGrid = document.getElementById('game-grid');
        const scoreElement = document.getElementById('score');
        const hintsElement = document.getElementById('hints');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreElement = document.getElementById('final-score');
        const pauseModal = document.getElementById('pause-modal');
        const soundBtn = document.getElementById('sound-btn');
        const messageBox = document.getElementById('message-box');
        
        // New DOM Elements
        const pressureLevelEl = document.getElementById('pressure-level');
        const characterEl = document.getElementById('character');
        const monsterEl = document.getElementById('monster');

        // --- Utility Functions ---

        // Display a message box instead of alert()
        function showMessage(msg) {
            messageBox.textContent = msg;
            messageBox.classList.remove('hidden');
            messageBox.classList.remove('opacity-0');
            
            // Set message box color based on content (e.g., green for good news)
            const isPositive = msg.includes("‡§Æ‡•à‡§ö") || msg.includes("‡§∏‡§Ç‡§ï‡•á‡§§");
            messageBox.style.backgroundColor = isPositive ? '#4CAF50' : '#00BCD4'; // Green or Cyan
            
            setTimeout(() => {
                messageBox.classList.add('opacity-0');
                setTimeout(() => messageBox.classList.add('hidden'), 300);
            }, 2000);
        }

        // Get Gem Type based on index
        function getGemType(index) {
            return GEM_TYPES[index % GEM_TYPES.length];
        }

        // Get Gem Color based on index
        function getGemColor(index) {
            return GEM_COLORS[index % GEM_COLORS.length];
        }

        // Update UI elements
        function updateUI() {
            scoreElement.textContent = gameState.score;
            hintsElement.textContent = gameState.hints;
            
            // Update Pressure/Monster Bar UI
            pressureLevelEl.style.width = `${gameState.waterLevel}%`;
            characterEl.style.left = `${gameState.characterX}%`;
            monsterEl.style.left = `${gameState.monsterX}%`;

            // Adjust character element style based on danger (pressure)
            if (gameState.waterLevel > 75) {
                 characterEl.style.backgroundColor = '#FF4500'; // Critical Red-Orange
            } else if (gameState.waterLevel > 50) {
                 characterEl.style.backgroundColor = '#FFD700'; // Warning Yellow/Gold
            } else {
                 characterEl.style.backgroundColor = '#4CAF50'; // Safe Green
            }
        }

        // --- Game Setup ---

        // Create the board data structure
        function createBoard() {
            gameState.board = [];
            for (let r = 0; r < ROWS; r++) {
                gameState.board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    let gemType;
                    do {
                        gemType = Math.floor(Math.random() * GEM_TYPES.length);
                    } while (checkMatchAt(r, c, gemType)); // Ensure no immediate matches on start
                    gameState.board[r][c] = gemType;
                }
            }
            renderBoard();
        }
        
        // Check for matches at a specific coordinate for a specific gem type
        function checkMatchAt(r, c, type) {
            // Check horizontal
            if (c >= 2 && gameState.board[r][c - 1] === type && gameState.board[r][c - 2] === type) return true;
            // Check vertical
            if (r >= 2 && gameState.board[r - 1] && gameState.board[r - 1][c] === type && gameState.board[r - 2][c] === type) return true;
            return false;
        }

        // Render the board to the DOM
        function renderBoard() {
            gameGrid.innerHTML = '';
            gameGrid.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
            gameGrid.style.gridTemplateRows = `repeat(${ROWS}, 1fr)`;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const gemIndex = gameState.board[r][c];
                    const gemDiv = document.createElement('div');
                    gemDiv.classList.add('gem');
                    gemDiv.id = `gem-${r}-${c}`;
                    gemDiv.textContent = getGemType(gemIndex);
                    gemDiv.style.backgroundColor = getGemColor(gemIndex);
                    gemDiv.dataset.row = r;
                    gemDiv.dataset.col = c;
                    gemDiv.dataset.type = gemIndex; // Store type for CSS targeting
                    gemDiv.addEventListener('click', handleGemClick);
                    gameGrid.appendChild(gemDiv);
                }
            }
        }

        // --- Game Loop and Logic ---

        // Main game loop
        function gameLoop(timestamp) {
            if (gameState.isPaused || gameState.isGameOver) {
                return;
            }

            const deltaTime = timestamp - gameState.lastTime;
            gameState.lastTime = timestamp;

            // Update game time
            if (!gameState.gameStartTime) {
                 gameState.gameStartTime = timestamp;
            }
            const timeElapsed = Math.floor((timestamp - gameState.gameStartTime) / 1000);
            document.getElementById('game-time').textContent = `${timeElapsed}s`;
            
            updateGameLogic(deltaTime / 1000); // Pass delta time in seconds

            updateUI();

            // Check Game Over
            if (gameState.isGameOver) {
                gameOver();
                return;
            }

            requestAnimationFrame(gameLoop);
        }

        // Core game mechanics update function
        function updateGameLogic(dt) {
            // 1. Water Pressure Increases
            gameState.waterLevel = Math.min(100, gameState.waterLevel + gameState.pressureRate * dt);
            
            // 2. Character Position is driven by Water Level (Pressure Wall)
            const charOffset = 2; // Keep character slightly away from the edge for visibility
            // Ensure character stops just before the 100% mark
            gameState.characterX = Math.min(96, Math.max(charOffset, gameState.waterLevel)); 

            
            // 3. Monster Movement (Moving Left towards Character)
            // The monster only moves if there is space between it and the character (5% minimum distance)
            const minMonsterDistance = 5;
            if (gameState.monsterX > gameState.characterX + minMonsterDistance) { 
                gameState.monsterX = Math.max(gameState.characterX + minMonsterDistance, gameState.monsterX - gameState.monsterSpeed * dt * 10);
            }

            // 4. Game Over Conditions
            // A. Pressure too high (pushed off the edge)
            if (gameState.characterX >= 96) {
                showMessage("‡§¶‡§¨‡§æ‡§µ ‡§¨‡§π‡•Å‡§§ ‡§Ö‡§ß‡§ø‡§ï ‡§π‡•ã ‡§ó‡§Ø‡§æ! (Pressure Overload!)");
                gameState.isGameOver = true;
                return;
            }
            
            // B. Monster reaches the character
            if (gameState.monsterX <= gameState.characterX + 1) { // 1% tolerance for collision
                showMessage("‡§Æ‡•â‡§®‡•ç‡§∏‡•ç‡§ü‡§∞ ‡§™‡§π‡•Å‡§Å‡§ö ‡§ó‡§Ø‡§æ! (Monster Reached You!)");
                gameState.isGameOver = true;
                return;
            }
        }


        // --- Match-3 Core Logic ---

        // Handles gem selection and swapping
        function handleGemClick(event) {
            if (gameState.isPaused || gameState.isGameOver || gameState.isProcessing) return;

            const r = parseInt(event.target.dataset.row);
            const c = parseInt(event.target.dataset.col);
            const currentGemEl = document.getElementById(`gem-${r}-${c}`);

            if (!gameState.selectedGem) {
                // First gem selected
                gameState.selectedGem = { r, c, el: currentGemEl };
                currentGemEl.classList.add('gem-selected');
            } else {
                // Second gem selected - check for validity
                const s = gameState.selectedGem;

                // Check if it's an adjacent gem (horizontal or vertical)
                const isAdjacent = (Math.abs(r - s.r) === 1 && c === s.c) || (Math.abs(c - s.c) === 1 && r === s.r);

                s.el.classList.remove('gem-selected'); // Deselect the first gem

                if (isAdjacent) {
                    gameState.isProcessing = true;
                    swapGems(r, c, s.r, s.c);
                } else {
                    // Not adjacent or clicked the same gem, select the new one
                    gameState.selectedGem = { r, c, el: currentGemEl };
                    currentGemEl.classList.add('gem-selected');
                }
            }
        }

        // Swaps gems in the data array and then processes matches
        function swapGems(r1, c1, r2, c2) {
            // Swap in data array
            [gameState.board[r1][c1], gameState.board[r2][c2]] = [gameState.board[r2][c2], gameState.board[r1][c1]];

            // Check for matches at both positions
            const matches = findMatches();

            if (matches.length > 0) {
                // Successful swap: process matches
                handleMatch(matches);
            } else {
                // Unsuccessful swap: swap back after a brief visual delay
                setTimeout(() => {
                    [gameState.board[r1][c1], gameState.board[r2][c2]] = [gameState.board[r2][c2], gameState.board[r1][c1]];
                    renderBoard(); // Re-render to show original state
                    gameState.isProcessing = false;
                }, 300);
            }
            
            gameState.selectedGem = null;
            renderBoard();
        }

        // Finds all matches (3 or more in a row/column)
        function findMatches() {
            const matches = [];
            const addMatch = (r, c) => {
                const id = `${r}-${c}`;
                if (!matches.some(m => m.id === id)) {
                    matches.push({ r, c, id });
                }
            };

            // Check Horizontal Matches
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS - 2; c++) {
                    const type = gameState.board[r][c];
                    if (gameState.board[r][c + 1] === type && gameState.board[r][c + 2] === type) {
                        let count = 0;
                        while (c + count < COLS && gameState.board[r][c + count] === type) {
                            addMatch(r, c + count);
                            count++;
                        }
                        c += count - 1; 
                    }
                }
            }

            // Check Vertical Matches
            for (let c = 0; c < COLS; c++) {
                for (let r = 0; r < ROWS - 2; r++) {
                    const type = gameState.board[r][c];
                    if (gameState.board[r + 1][c] === type && gameState.board[r + 2][c] === type) {
                        let count = 0;
                        while (r + count < ROWS && gameState.board[r + count][c] === type) {
                            addMatch(r + count, c);
                            count++;
                        }
                        r += count - 1;
                    }
                }
            }
            return matches;
        }

        // Processes the matched gems
        function handleMatch(matches) {
            gameState.isProcessing = true;

            // 1. Scoring and Draining Pressure
            const scorePerGem = 10;
            const scoreGain = matches.length * scorePerGem;
            gameState.score += scoreGain;
            
            // DRAIN PRESSURE: Match-3 ‡§∏‡§´‡§≤ ‡§π‡•ã‡§®‡•á ‡§™‡§∞ ‡§™‡§æ‡§®‡•Ä ‡§ï‡§æ ‡§∏‡•ç‡§§‡§∞ (‡§¶‡§¨‡§æ‡§µ) ‡§ï‡§Æ ‡§π‡•ã‡§§‡§æ ‡§π‡•à
            const drain = Math.min(gameState.waterLevel - 2, gameState.drainAmount); // Can't drain below starting level 2%
            gameState.waterLevel = Math.max(2, gameState.waterLevel - drain); 
            
            // Monster is pushed back
            const monsterPushback = drain * 0.8; 
            gameState.monsterX = Math.min(98, gameState.monsterX + monsterPushback); 

            showMessage(`‡§Æ‡•à‡§ö! +${scoreGain} ‡§Ö‡§Ç‡§ï, ‡§¶‡§¨‡§æ‡§µ ‡§ï‡§Æ ‡§π‡•Å‡§Ü, ‡§î‡§∞ ‡§Æ‡•â‡§®‡•ç‡§∏‡•ç‡§ü‡§∞ ‡§™‡•Ä‡§õ‡•á ‡§π‡§ü‡§æ!`);

            // 2. Visual removal
            matches.forEach(m => {
                const gemEl = document.getElementById(`gem-${m.r}-${m.c}`);
                if (gemEl) gemEl.classList.add('gem-remove');
            });

            setTimeout(() => {
                // 3. Drop and Refill
                removeMatches(matches);
                dropGems();
                refillBoard();
                
                // 4. Check for cascade matches
                const newMatches = findMatches();
                if (newMatches.length > 0) {
                    handleMatch(newMatches); // Recursively process cascades
                } else {
                    // All cascades finished
                    gameState.isProcessing = false;
                }
                renderBoard();
            }, 300); // Wait for removal animation
        }

        // Remove matched gems from the data array
        function removeMatches(matches) {
            matches.forEach(m => {
                gameState.board[m.r][m.c] = -1; // -1 represents an empty spot
            });
        }

        // Drop gems down to fill empty spaces
        function dropGems() {
            for (let c = 0; c < COLS; c++) {
                let emptySpots = 0;
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (gameState.board[r][c] === -1) {
                        emptySpots++;
                    } else if (emptySpots > 0) {
                        gameState.board[r + emptySpots][c] = gameState.board[r][c];
                        gameState.board[r][c] = -1;
                    }
                }
            }
        }

        // Refill the top empty spaces with new random gems
        function refillBoard() {
            for (let c = 0; c < COLS; c++) {
                for (let r = 0; r < ROWS; r++) {
                    if (gameState.board[r][c] === -1) {
                        let gemType;
                        do {
                             gemType = Math.floor(Math.random() * GEM_TYPES.length);
                        } while (checkMatchAt(r, c, gemType)); // Ensure no immediate matches on refill
                        gameState.board[r][c] = gemType;
                    }
                }
            }
        }

        // Use a hint to find a possible swap
        function useHint() {
            if (gameState.isPaused || gameState.isGameOver || gameState.hints <= 0) {
                showMessage("‡§∏‡§Ç‡§ï‡•á‡§§ ‡§®‡§π‡•Ä‡§Ç ‡§¨‡§ö‡•á ‡§π‡•à‡§Ç ‡§Ø‡§æ ‡§ñ‡•á‡§≤ ‡§∞‡•Å‡§ï‡§æ ‡§π‡•Å‡§Ü ‡§π‡•à‡•§");
                return;
            }

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    // Check right swap
                    if (c < COLS - 1) {
                        if (canSwapAndMatch(r, c, r, c + 1)) return highlightHint(r, c, r, c + 1);
                    }
                    // Check down swap
                    if (r < ROWS - 1) {
                        if (canSwapAndMatch(r, c, r + 1, c)) return highlightHint(r, c, r + 1, c);
                    }
                }
            }
            showMessage("‡§ï‡•ã‡§à ‡§ö‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡•Ä!");
        }

        function canSwapAndMatch(r1, c1, r2, c2) {
            [gameState.board[r1][c1], gameState.board[r2][c2]] = [gameState.board[r2][c2], gameState.board[r1][c1]];
            const matches = findMatches();
            [gameState.board[r1][c1], gameState.board[r2][c2]] = [gameState.board[r2][c2], gameState.board[r1][c1]];
            return matches.length > 0;
        }

        function highlightHint(r1, c1, r2, c2) {
            gameState.hints--;
            updateUI();
            
            const el1 = document.getElementById(`gem-${r1}-${c1}`);
            const el2 = document.getElementById(`gem-${r2}-${c2}`);

            // Custom highlight style
            el1.style.boxShadow = '0 0 25px 7px #00FFFF';
            el2.style.boxShadow = '0 0 25px 7px #00FFFF';
            
            setTimeout(() => {
                el1.style.boxShadow = '0 3px 6px var(--gem-shadow)';
                el2.style.boxShadow = '0 3px 6px var(--gem-shadow)';
            }, 1000);
            
            showMessage("‡§∏‡§Ç‡§ï‡•á‡§§ ‡§Æ‡§ø‡§≤‡§æ! ‡§á‡§® ‡§¶‡•ã ‡§∞‡§§‡•ç‡§®‡•ã‡§Ç ‡§ï‡•ã ‡§¨‡§¶‡§≤‡•á‡§Ç‡•§");
        }


        // --- Game Flow Control ---

        // Initialize or restart the game
        function init() {
            // Reset state
            gameState.score = 0;
            gameState.hints = 3;
            gameState.isPaused = false;
            gameState.isGameOver = false;
            gameState.selectedGem = null;
            gameState.isProcessing = false;
            gameState.gameStartTime = performance.now(); 
            
            // Reset new mechanics state
            gameState.waterLevel = 2; // Start slightly off 0
            gameState.characterX = 2; // Start left (safe)
            gameState.monsterX = 98; // Start right (far)

            gameOverModal.classList.add('hidden');
            pauseModal.classList.add('hidden');
            
            createBoard();
            updateUI();
            
            // Start the main loop
            gameState.lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // Game over
        function gameOver() {
            gameState.isGameOver = true;
            finalScoreElement.textContent = gameState.score;
            gameOverModal.classList.remove('hidden');
        }

        // Toggle pause
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            
            if (gameState.isPaused) {
                pauseModal.classList.remove('hidden');
            } else {
                pauseModal.classList.add('hidden');
                gameState.lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }

        // Toggle sound (Placeholder)
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            soundBtn.textContent = gameState.soundEnabled ? 'üîä' : 'üîá';
            showMessage(gameState.soundEnabled ? "‡§ß‡•ç‡§µ‡§®‡§ø ‡§ö‡§æ‡§≤‡•Ç" : "‡§ß‡•ç‡§µ‡§®‡§ø ‡§¨‡§Ç‡§¶");
        }

        // Initialize the game when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
