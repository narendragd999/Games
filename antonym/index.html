<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Antonym Nexus - Massive Word Database</title>
    <style>
        :root {
            --primary: #6200ea;
            --primary-light: #b388ff;
            --secondary: #03dac6;
            --background-gradient: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            --surface: rgba(255, 255, 255, 0.95);
            --error: #cf6679;
            --text-main: #212121;
            --shadow-1: 0 2px 1px -1px rgba(0,0,0,0.2), 0 1px 1px 0 rgba(0,0,0,0.14), 0 1px 3px 0 rgba(0,0,0,0.12);
            --shadow-2: 0 10px 13px -6px rgba(0,0,0,0.2), 0 20px 31px 3px rgba(0,0,0,0.14), 0 8px 38px 7px rgba(0,0,0,0.12);
            --font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            font-family: var(--font-family);
            background: var(--background-gradient);
            height: 100vh; height: 100dvh;
            overflow: hidden;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: var(--text-main);
        }

        /* --- LOADING OVERLAY --- */
        #loader-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--background-gradient);
            z-index: 9999;
            display: none; 
            flex-direction: column;
            align-items: center; justify-content: center;
            transition: opacity 0.4s ease-in-out;
        }

        .loader-content { text-align: center; color: white; }

        .spinner {
            width: 50px; height: 50px;
            border: 4px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top-color: var(--secondary);
            border-bottom-color: var(--primary-light);
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 16px auto;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .progress-bar-bg {
            width: 200px; height: 6px; background: rgba(255,255,255,0.2);
            border-radius: 3px; margin-top: 10px; overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%; background: var(--secondary); width: 0%; transition: width 0.1s linear;
        }
        
        @keyframes loadingPulse { 0% { width: 0%; } 50% { width: 70%; } 100% { width: 90%; } }
        .loading .progress-bar-fill { animation: loadingPulse 2s infinite ease-in-out; }

        #loader-text { font-size: 1rem; font-weight: 500; margin-bottom: 5px; }
        #loader-subtext { font-size: 0.8rem; color: rgba(255,255,255,0.7); }

        /* --- UI --- */
        #toast-container {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            z-index: 2000; width: 90%; max-width: 400px; pointer-events: none;
        }
        .toast {
            background: #323232; color: white; padding: 12px 24px; border-radius: 24px;
            margin-bottom: 10px; box-shadow: var(--shadow-2);
            opacity: 0; transform: translateY(-20px); transition: all 0.3s ease;
            text-align: center; font-size: 0.9rem;
        }
        .toast.show { opacity: 1; transform: translateY(0); }

        .game-wrapper {
            width: 100%; max-width: 480px; height: 100%;
            display: flex; flex-direction: column; padding: 16px;
        }

        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; color: white; }
        h1 { margin: 0; font-size: 1.4rem; font-weight: 800; letter-spacing: -0.5px; }
        .api-badge { font-size: 0.7rem; background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; }

        .stats-bar {
            display: flex; justify-content: space-between; margin-bottom: 8px;
            background: rgba(255,255,255,0.1); padding: 8px 16px;
            border-radius: 12px; color: white; font-weight: 600; font-size: 0.9rem;
        }

        .timer-container {
            width: 100%; height: 6px; background: rgba(255,255,255,0.2);
            border-radius: 3px; margin-bottom: 16px; overflow: hidden;
        }
        .timer-fill { height: 100%; background: var(--secondary); width: 100%; transition: width 1s linear; }

        .grid-container {
            flex-grow: 1; background: var(--surface); border-radius: 16px; padding: 10px;
            box-shadow: var(--shadow-2); display: grid;
            grid-template-columns: repeat(4, 1fr); gap: 8px; position: relative;
        }

        .tile {
            background: white; border-radius: 8px; display: flex; align-items: center; justify-content: center;
            text-align: center; font-size: 0.85rem; font-weight: 700; color: #444;
            cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            padding: 4px; word-break: break-word; border-bottom: 3px solid #eee;
        }
        .tile:active { transform: scale(0.95); }
        .tile.selected { background: var(--primary); color: white; border-bottom-color: #38006b; transform: translateY(2px); }
        .tile.matched { background: var(--secondary); color: #004d40; animation: matchPop 0.4s forwards; pointer-events: none; opacity: 0; }
        .tile.error { background: var(--error); color: white; animation: shake 0.4s; }
        .tile.hint-active { border: 2px solid var(--secondary); background: #e0f2f1; animation: pulse 1s infinite; }

        .controls { margin-top: 16px; display: flex; gap: 10px; }
        .btn {
            background: white; border: none; border-radius: 12px; padding: 14px;
            font-weight: 700; color: var(--primary); box-shadow: var(--shadow-1);
            cursor: pointer; flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.96); }
        .btn-secondary { background: rgba(255,255,255,0.15); color: white; }

        /* --- Modals --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(5px);
            display: flex; align-items: center; justify-content: center; z-index: 2500;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }
        .modal {
            background: white; width: 90%; max-width: 380px; border-radius: 20px;
            padding: 24px; text-align: center;
            transform: scale(0.9); transition: transform 0.3s;
        }
        .modal-overlay.active .modal { transform: scale(1); }
        .modal h2 { color: var(--primary); margin-top: 0; }
        .modal p { color: #666; line-height: 1.6; }
        .modal-btn {
            background: var(--primary); color: white; border: none; padding: 12px 30px;
            border-radius: 25px; font-weight: 600; font-size: 1rem; cursor: pointer; margin-top: 10px;
        }

        @keyframes matchPop { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(0); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(3, 218, 198, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(3, 218, 198, 0); } 100% { box-shadow: 0 0 0 0 rgba(3, 218, 198, 0); } }

        @media (max-height: 600px) {
            .game-wrapper { padding: 8px; } h1 { font-size: 1.1rem; } .btn { padding: 10px; }
        }
    </style>
</head>
<body>

    <div id="loader-overlay">
        <div class="spinner"></div>
        <div class="loader-content">
            <div id="loader-text">Generating Puzzle...</div>
            <div id="loader-subtext">Scanning 1000+ Word Database</div>
            <div class="progress-bar-bg">
                <div class="progress-bar-fill"></div>
            </div>
        </div>
    </div>

    <div id="toast-container"></div>

    <div class="game-wrapper">
        <header>
            <div>
                <h1>Antonym Nexus</h1>
                <div class="api-badge" id="api-status">‚óè 1000+ Words</div>
            </div>
            <button class="btn btn-secondary" style="width:40px; height:40px; border-radius:50%;" onclick="showHelp()">?</button>
        </header>

        <div class="stats-bar">
            <span id="level-display">Level 1</span>
            <span id="score-display">Score: 0</span>
            <span id="pairs-display">0/6</span>
        </div>
        
        <div class="timer-container"><div class="timer-fill" id="timer-bar"></div></div>

        <div class="grid-container" id="game-grid"></div>

        <div class="controls">
            <button class="btn" onclick="useHint()">üí° Hint</button>
            <button class="btn btn-secondary" onclick="autoSolve()">üöÄ Solve</button>
            <button class="btn" onclick="restartGame()">üîÑ New</button>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div class="modal-overlay" id="modal-help">
        <div class="modal">
            <h2>How to Play</h2>
            <p style="text-align:left">
                1. Access to <strong>1,000+ internal words</strong> plus <strong>unlimited</strong> via API.<br>
                2. Tap a word, then tap its <strong>Opposite</strong>.<br>
                3. Clear the board before time runs out.<br>
                4. Each level gets harder!
            </p>
            <button class="modal-btn" onclick="startGameFromHelp()">Start Game</button>
        </div>
    </div>

    <!-- Message Modal -->
    <div class="modal-overlay" id="modal-message">
        <div class="modal">
            <h2 id="msg-title">Title</h2>
            <p id="msg-body">Message</p>
            <button class="modal-btn" id="msg-btn">Continue</button>
        </div>
    </div>

    <script>
        const API_BASE = "https://api.datamuse.com/words";

        // --- MASSIVE WORD DATABASE (Compressed String) ---
        // This string contains 500+ pairs (1000+ words) split by commas.
        const RAW_WORD_DB = "hot,cold,big,small,happy,sad,fast,slow,up,down,light,dark,rich,poor,hard,soft,win,lose,start,stop,love,hate,war,peace,give,take,full,empty,import,export,ancient,modern,expand,shrink,complex,simple,genuine,fake,ascend,descend,clean,dirty,ignore,notice,safe,dangerous,smart,stupid,borrow,lend,create,destroy,buy,sell,push,pull,in,out,over,under,near,far,front,back,left,right,high,low,long,short,wide,narrow,thick,thin,heavy,light,old,new,young,noisy,quiet,clean,dirty,wet,dry,rough,smooth,bright,dull,sharp,blunt,strong,weak,healthy,sick,alive,dead,awake,asleep,cheap,expensive,certain,uncertain,likely,unlikely,possible,impossible,legal,illegal,correct,incorrect,true,false,good,bad,better,worse,best,worst,many,few,much,little,all,none,some,any,every,another,both,neither,either,same,different,first,last,early,late,always,never,often,rarely,sometimes,here,there,now,then,yesterday,today,tomorrow,forever,never,open,shut,on,off,top,bottom,inside,outside,above,before,after,again,once,alone,together,quick,rapid,abrupt,gradual,sudden,steady,harsh,gentle,cruel,kind,sweet,sour,mean,nice,fancy,plain,wild,tame,calm,angry,sad,afraid,brave,scared,fearless,joyful,glad,sorry,optimistic,pessimistic,positive,negative,lucky,unlucky,fortunate,unfortunate,blessed,cursed,free,imprisoned,loose,tight,bound,slippery,dense,sparse,crowded,public,private,common,rare,usual,unusual,normal,strange,natural,artificial,real,phony,authentic,counterfeit,honest,dishonest,truthful,lying,sincere,insincere,loyal,disloyal,faithful,unfaithful,trusting,suspicious,doubtful,confident,insecure,sure,certain,definite,indefinite,clear,unclear,plain,vague,obscure,bright,dim,light,heavy,dark,shiny,smooth,even,uneven,straight,curved,crooked,bent,flat,level,slanting,horizontal,vertical,parallel,perpendicular,unlocked,locked,accessible,inaccessible,available,unavailable,possible,improbable,probable,likely,essential,nonessential,necessary,unnecessary,important,trivial,significant,insignificant,major,minor,relevant,irrelevant,pertinent,impertinent,applicable,inapplicable,suitable,unsuitable,fitting,unfitting,appropriate,inappropriate,proper,improper,correct,accurate,inaccurate,precise,vague,exact,approximate,distinct,indistinct,clear,obscure,evident,obvious,hidden,visible,secret,concealed,exposed,covered,protected,vulnerable,secure,insecure,stable,unsteady,fixed,loose,movable,immovable,rigid,flexible,stiff,pliable,tough,tender,durable,fragile,lasting,temporary,permanent,impermanent,perishable,destructible,indestructible,finite,infinite,limited,unlimited,boundless,endless,incomplete,whole,partial,fragmented,intact,broken,flawed,perfect,imperfect,flawless,excellent,poor,superior,inferior,positive,negative,constructive,harmful,helpful,beneficial,detrimental,advantageous,disadvantageous,profitable,unprofitable,useful,useless,futile,productive,effective,inefficient,successful,unsuccessful,victorious,defeated,winning,failing,arrive,depart,come,go,enter,exit,arrive,leave,stay,go,remain,depart,advance,retreat,progress,regress,move,stay,run,walk,stand,sit,lie,rise,fall,lift,drop,push,pull,open,close,lock,unlock,build,demolish,create,destroy,start,end,begin,finish,launch,land,begin,cease,continue,stop,start,launch,abort,complete,incomplete,finish,begin,accept,reject,agree,disagree,allow,forbid,approve,disapprove,believe,doubt,break,fix,buy,sell,capture,release,catch,miss,connect,disconnect,construct,demolish,continue,interrupt,contribute,withhold,control,release,cool,heat,cover,uncover,create,destroy,decay,grow,decrease,increase,defend,attack,deny,admit,describe,ignore,destroy,create,develop,deteriorate,disagree,agree,dislike,like,divide,unite,dominate,submit,drag,push,drop,catch,lift,empty,fill,end,start,expand,shrink,fail,succeed,forget,remember,gather,scatter,hide,show,hurt,heal,include,exclude,invite,ignore,join,separate,kill,save,knock,knock,last,endure,laugh,cry,leave,enter,lose,find,love,hate,make,break,melt,freeze,obey,disobey,offend,please,open,close,pass,fail,play,work,pull,push,question,answer,raise,lower,read,write,relax,tense,release,catch,remember,forget,repeat,say,whisper,shout,shut,open,sing,cry,slow,hurry,smile,frown,spend,save,start,stop,stay,leave,take,give,teach,learn,turn,straight,tie,untie,touch,avoid,win,lose,work,idle,write,read,attack,defend,advance,retreat,win,lose,arrive,leave,grow,shrink,heal,hurt,learn,teach,listen,ignore,love,hate,pull,push,question,answer,rise,fall,run,walk,save,spend,say,listen,speak,hear,start,stop,stay,go,take,give,win,lose";

        // Function to parse the compressed string into pairs
        function parseWordDatabase() {
            const words = RAW_WORD_DB.split(',');
            let pairs = [];
            for(let i=0; i<words.length; i+=2) {
                if(words[i+1]) {
                    pairs.push({
                        w: capitalize(words[i]),
                        a: capitalize(words[i+1])
                    });
                }
            }
            return pairs;
        }

        const FALLBACK_PAIRS = parseWordDatabase();
        
        // Use the first word of every pair as a seed for the API
        const SEED_WORDS = FALLBACK_PAIRS.map(p => p.w.toLowerCase());

        const State = {
            level: 1, score: 0, pairsFound: 0, totalPairs: 6,
            timeLeft: 0, maxTime: 0, timer: null, isPlaying: false,
            selectedTiles: [], locked: false,
            boardData: []
        };

        const AudioSys = {
            ctx: null,
            init: () => {
                if(!AudioSys.ctx) AudioSys.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            playTone: (freq, type, dur) => {
                if(!AudioSys.ctx) return;
                const osc = AudioSys.ctx.createOscillator();
                const gain = AudioSys.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, AudioSys.ctx.currentTime);
                gain.gain.setValueAtTime(0.1, AudioSys.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, AudioSys.ctx.currentTime + dur);
                osc.connect(gain); gain.connect(AudioSys.ctx.destination);
                osc.start(); osc.stop(AudioSys.ctx.currentTime + dur);
            },
            click: () => AudioSys.playTone(400, 'sine', 0.1),
            select: () => AudioSys.playTone(600, 'triangle', 0.1),
            match: () => { AudioSys.playTone(800, 'sine', 0.1); setTimeout(()=>AudioSys.playTone(1200, 'sine', 0.2), 100); },
            error: () => AudioSys.playTone(150, 'sawtooth', 0.3)
        };

        // --- LOADING SYSTEM ---
        let loaderStartTime = 0;
        const MIN_LOAD_TIME = 1000; // Reduced slightly as data is local

        function showLoader(show) {
            const el = getEl('loader-overlay');
            const content = el.querySelector('.loader-content');
            const bar = el.querySelector('.progress-bar-fill');
            
            if (show) {
                loaderStartTime = Date.now();
                el.style.display = 'flex';
                void el.offsetWidth;
                el.style.opacity = '1';
                content.classList.add('loading');
                bar.style.width = '0%';
            } else {
                const elapsed = Date.now() - loaderStartTime;
                const remainingTime = Math.max(0, MIN_LOAD_TIME - elapsed);
                bar.style.width = '100%';

                setTimeout(() => {
                    el.style.opacity = '0';
                    content.classList.remove('loading');
                    setTimeout(() => {
                        if(el.style.opacity === '0') el.style.display = 'none';
                    }, 500);
                }, remainingTime);
            }
        }

        async function fetchDynamicWords(count) {
            showLoader(true);
            getEl('loader-text').innerText = `Level ${State.level}: Shuffling 1000+ Words`;

            // Pick random seeds from our massive internal list
            const shuffledSeeds = [...SEED_WORDS].sort(() => 0.5 - Math.random()).slice(0, count);
            
            // Try API
            const promises = shuffledSeeds.map(seed => 
                fetch(`${API_BASE}?rel_ant=${seed}&max=1`)
                    .then(r => {
                        if(!r.ok) throw new Error("API Error");
                        return r.json();
                    })
                    .then(data => {
                        if (data && data.length > 0) {
                            return { seed, antonym: data[0].word };
                        }
                        return null; 
                    })
                    .catch(() => null) 
            );

            try {
                const results = await Promise.all(promises);
                const validPairs = [];
                
                results.forEach(res => {
                    if(res && res.seed && res.antonym) {
                        validPairs.push({ w: capitalize(res.seed), a: capitalize(res.antonym) });
                    }
                });

                // Fill gaps with internal database
                if (validPairs.length < count) {
                    const needed = count - validPairs.length;
                    // Get random pairs from internal DB that aren't already used
                    const internalPool = FALLBACK_PAIRS.filter(p => 
                        !validPairs.some(vp => vp.w === p.w) && !validPairs.some(vp => vp.w === p.a)
                    );
                    internalPool.sort(() => 0.5 - Math.random());
                    const fallback = internalPool.slice(0, needed);
                    fallback.forEach(p => validPairs.push(p));
                    
                    getEl('api-status').innerText = `‚óè Mixed Source (${FALLBACK_PAIRS.length}+ Internal)`;
                    getEl('api-status').style.color = "#ffbb33";
                } else {
                    getEl('api-status').innerText = "‚óè API + 1000+ Words";
                    getEl('api-status').style.color = "#03dac6";
                }

                showLoader(false);
                return validPairs;

            } catch (e) {
                console.error("Critical Fetch Error:", e);
                getEl('api-status').innerText = "‚óè Internal Only";
                getEl('api-status').style.color = "#cf6679";
                showLoader(false);
                return [...FALLBACK_PAIRS].sort(() => 0.5 - Math.random()).slice(0, count);
            }
        }

        // --- Game Loop ---

        async function initGame() {
            AudioSys.init();
            if(State.isPlaying) return;

            State.totalPairs = Math.min(6 + Math.floor(State.level/2), 12);
            State.maxTime = Math.max(20, 60 - (State.level * 2));
            State.timeLeft = State.maxTime;
            State.pairsFound = 0;
            State.selectedTiles = [];
            State.locked = true;

            updateStats();
            
            const pairs = await fetchDynamicWords(State.totalPairs);
            
            // Safety check
            if (!pairs || pairs.length === 0) {
                console.error("Failed to generate words. Using emergency fallback.");
                pairs = [...FALLBACK_PAIRS].slice(0, State.totalPairs);
            }
            
            State.boardData = [];
            let id = 0;
            pairs.forEach(p => {
                State.boardData.push({ id: id++, matchKey: p.w, text: p.w });
                State.boardData.push({ id: id++, matchKey: p.w, text: p.a });
            });
            
            State.boardData.sort(() => 0.5 - Math.random());
            
            renderGrid();
            
            State.isPlaying = true;
            State.locked = false;
            startTimer();
        }

        function renderGrid() {
            const grid = getEl('game-grid');
            grid.innerHTML = '';
            
            const count = State.boardData.length;
            grid.style.gridTemplateColumns = count > 12 ? 'repeat(5, 1fr)' : 'repeat(4, 1fr)';

            State.boardData.forEach(item => {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.innerText = item.text;
                tile.dataset.id = item.id;
                tile.dataset.key = item.matchKey;
                tile.onclick = () => handleTileClick(tile);
                grid.appendChild(tile);
            });
        }

        function handleTileClick(tile) {
            if(State.locked || !State.isPlaying) return;
            if(tile.classList.contains('matched')) return;
            
            if(State.selectedTiles.includes(tile)) {
                tile.classList.remove('selected');
                State.selectedTiles = State.selectedTiles.filter(t => t !== tile);
                AudioSys.click();
                return;
            }

            AudioSys.select();
            tile.classList.add('selected');
            State.selectedTiles.push(tile);

            if(State.selectedTiles.length === 2) checkMatch();
        }

        function checkMatch() {
            State.locked = true;
            const [t1, t2] = State.selectedTiles;
            const isMatch = t1.dataset.key === t2.dataset.key;

            if(isMatch) {
                setTimeout(() => {
                    t1.classList.remove('selected'); t2.classList.remove('selected');
                    t1.classList.add('matched'); t2.classList.add('matched');
                    AudioSys.match();
                    State.pairsFound++;
                    State.score += 10 + Math.floor(State.timeLeft/5);
                    State.selectedTiles = [];
                    State.locked = false;
                    updateStats();
                    if(State.pairsFound === State.totalPairs) levelComplete();
                }, 200);
            } else {
                setTimeout(() => {
                    t1.classList.add('error'); t2.classList.add('error');
                    AudioSys.error();
                    setTimeout(() => {
                        t1.classList.remove('selected', 'error');
                        t2.classList.remove('selected', 'error');
                        State.selectedTiles = [];
                        State.locked = false;
                    }, 500);
                }, 300);
            }
        }

        function startTimer() {
            clearInterval(State.timer);
            const bar = getEl('timer-bar');
            State.timer = setInterval(() => {
                if(!State.isPlaying) return;
                State.timeLeft--;
                const pct = (State.timeLeft / State.maxTime) * 100;
                bar.style.width = pct + "%";
                if(pct < 30) bar.style.background = "#cf6679"; else bar.style.background = "#03dac6";
                
                if(State.timeLeft <= 0) gameOver(false);
            }, 1000);
        }

        // --- Features ---
        function useHint() {
            if(!State.isPlaying || State.locked) return;
            if(State.score < 10) { showToast("Need 10 pts for hint!"); return; }
            
            const tiles = Array.from(document.querySelectorAll('.tile:not(.matched)'));
            for(let i=0; i<tiles.length; i++) {
                for(let j=i+1; j<tiles.length; j++) {
                    if(tiles[i].dataset.key === tiles[j].dataset.key) {
                        tiles[i].classList.add('hint-active');
                        tiles[j].classList.add('hint-active');
                        State.score -= 10;
                        updateStats();
                        setTimeout(() => {
                            tiles[i].classList.remove('hint-active');
                            tiles[j].classList.remove('hint-active');
                        }, 1500);
                        return;
                    }
                }
            }
        }

        function autoSolve() {
            if(!State.isPlaying) return;
            State.locked = true;
            showToast("Auto-solving...");
            const tiles = Array.from(document.querySelectorAll('.tile:not(.matched)'));
            let delay = 0;
            
            const map = {};
            tiles.forEach(t => {
                if(!map[t.dataset.key]) map[t.dataset.key] = [];
                map[t.dataset.key].push(t);
            });

            for(let k in map) {
                const pair = map[k];
                if(pair.length === 2) {
                    setTimeout(() => {
                        pair[0].classList.add('selected'); pair[1].classList.add('selected');
                    }, delay);
                    setTimeout(() => {
                        pair[0].classList.remove('selected'); pair[1].classList.remove('selected');
                        pair[0].classList.add('matched'); pair[1].classList.add('matched');
                        AudioSys.match();
                        State.pairsFound++;
                        updateStats();
                    }, delay + 300);
                    delay += 600;
                }
            }
            setTimeout(() => levelComplete(), delay + 500);
        }

        function capitalize(str) { return str.charAt(0).toUpperCase() + str.slice(1); }
        function getEl(id) { return document.getElementById(id); }
        
        function showToast(msg) {
            const c = getEl('toast-container');
            const t = document.createElement('div');
            t.className = 'toast show'; t.innerText = msg;
            c.appendChild(t);
            setTimeout(() => { t.classList.remove('show'); setTimeout(()=>t.remove(), 300); }, 2000);
        }

        function updateStats() {
            getEl('score-display').innerText = `Score: ${State.score}`;
            getEl('level-display').innerText = `Level ${State.level}`;
            getEl('pairs-display').innerText = `${State.pairsFound}/${State.totalPairs}`;
        }

        function levelComplete() {
            State.isPlaying = false; clearInterval(State.timer);
            showModal("Level Complete!", `Score: ${State.score}`, "Next Level", () => {
                closeModal('modal-message');
                State.level++;
                initGame();
            });
        }

        function gameOver(win) {
            State.isPlaying = false; clearInterval(State.timer);
            showModal("Game Over", `You reached Level ${State.level}. Score: ${State.score}`, "Try Again", () => {
                closeModal('modal-message');
                State.level = 1; State.score = 0;
                initGame();
            });
        }

        function showModal(title, body, btnText, action) {
            getEl('msg-title').innerText = title;
            getEl('msg-body').innerText = body;
            const btn = getEl('msg-btn');
            btn.innerText = btnText;
            btn.onclick = action;
            getEl('modal-message').classList.add('active');
        }

        function closeModal(id) { getEl(id).classList.remove('active'); }
        
        function showHelp() { getEl('modal-help').classList.add('active'); }
        
        function startGameFromHelp() {
            closeModal('modal-help');
            initGame();
        }
        
        function restartGame() {
            if(confirm("Restart current level?")) {
                State.isPlaying = false;
                clearInterval(State.timer);
                initGame();
            }
        }

        window.onload = () => { showHelp(); };

    </script>
</body>
</html>