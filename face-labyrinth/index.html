<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Tilt: Direct Control</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background: #0a0a0a;
            box-shadow: 0 0 50px rgba(0, 100, 255, 0.2);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.8);
            transition: opacity 0.3s;
        }

        .screen {
            background: rgba(20, 30, 40, 0.95);
            padding: 40px;
            border: 2px solid #00d2ff;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 30px #00d2ff;
            max-width: 500px;
        }

        h1 { margin: 0 0 15px 0; color: #00d2ff; letter-spacing: 2px; text-transform: uppercase;}
        p { font-size: 1.1rem; color: #ccc; margin-bottom: 20px; line-height: 1.5; }
        
        button {
            background: #00d2ff;
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
        }
        button:hover { background: #fff; }

        #input-video { display: none; }
        .hidden { display: none !important; }

        /* Debug Panel */
        #debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border: 1px solid #444;
            font-family: monospace;
            font-size: 12px;
            color: #0f0;
            pointer-events: none;
        }
        .indicator { font-weight: bold; font-size: 14px; }
        .left-arr { color: #ff4444; }
        .right-arr { color: #4488ff; }
    </style>
</head>
<body>

    <div id="game-container">
        <video id="input-video"></video>
        <canvas id="game-canvas"></canvas>

        <div id="debug-panel">
            RAW ANGLE: <span id="dbg-raw">0</span><br>
            NEUTRAL: <span id="dbg-neutral">0</span><br>
            NET TILT: <span id="dbg-tilt">0</span><br>
            DIRECTION: <span id="dbg-dir" class="indicator">CENTER</span><br>
            <br>
            <strong>[SPACEBAR]</strong> to Recalibrate Center
        </div>

        <div id="ui-layer">
            <div id="start-screen" class="screen">
                <h1>Direct Control Mode</h1>
                <p>Fixed the direction bug. The ball is now locked to your head.</p>
                <p><strong>Controls:</strong></p>
                <ul style="text-align: left; color: #aaa; display: inline-block;">
                    <li>Look Straight = Ball Stops</li>
                    <li>Look Left = Ball Goes Left</li>
                    <li>Look Right = Ball Goes Right</li>
                </ul>
                <br>
                <button id="btn-start">Start Game</button>
            </div>

            <div id="game-over-screen" class="screen hidden">
                <h1 style="color: #ff4444;">CRASHED!</h1>
                <p>Wall impact detected.</p>
                <h2 id="final-score">Score: 0</h2>
                <button id="btn-restart">Try Again</button>
            </div>
        </div>
    </div>

<script>
    // --- Configuration ---
    const CONFIG = {
        ballSize: 12,
        sensitivity: 15,       // How many pixels the ball moves per 1 degree of tilt
        deadzone: 2.0,         // Ignore small head movements (jitter)
        wallSpeed: 4,          
        spawnRate: 80,
        gapSize: 110,
        gapSpeedBase: 3
    };

    // --- Game State ---
    const state = {
        isPlaying: false,
        score: 0,
        frames: 0,
        headTilt: 0,
        neutralTilt: 0,
        ball: { x: 0, y: 0 },
        walls: []
    };

    // --- Elements ---
    const videoElement = document.getElementById('input-video');
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const uiLayer = document.getElementById('ui-layer');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const scoreDisplay = document.getElementById('final-score');
    
    // Debug elements
    const dbgRaw = document.getElementById('dbg-raw');
    const dbgNeutral = document.getElementById('dbg-neutral');
    const dbgTilt = document.getElementById('dbg-tilt');
    const dbgDir = document.getElementById('dbg-dir');

    // --- Resize ---
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        state.ball.y = canvas.height - 150; 
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // --- MediaPipe Face Mesh Setup ---
    const faceMesh = new FaceMesh({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
    }});

    faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    faceMesh.onResults(onFaceResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await faceMesh.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    camera.start();

    function onFaceResults(results) {
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            const landmarks = results.multiFaceLandmarks[0];
            const leftEye = landmarks[33];
            const rightEye = landmarks[263];
            
            // Calculate Angle
            const angle = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x);
            state.headTilt = angle * (180 / Math.PI);
        }
    }

    function calibrateTilt() {
        state.neutralTilt = state.headTilt;
        console.log("Recalibrated. New Neutral:", state.neutralTilt);
    }

    // --- Game Logic ---

    function startGame() {
        calibrateTilt();
        state.isPlaying = true;
        state.score = 0;
        state.frames = 0;
        state.walls = [];

        uiLayer.classList.add('hidden');
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');

        createWall(canvas.height + 300);
        requestAnimationFrame(gameLoop);
    }

    // Spacebar to Recalibrate
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && state.isPlaying) {
            calibrateTilt();
        }
    });

    function createWall(yPos) {
        const randomX = Math.random() * (canvas.width - 200) + 100;
        const direction = Math.random() > 0.5 ? 1 : -1;
        const speed = (Math.random() * 2) + 1; 
        state.walls.push({
            y: yPos,
            gapX: randomX,
            gapDirection: direction,
            gapSpeed: speed,
            height: 40
        });
    }

    function gameOver() {
        state.isPlaying = false;
        scoreDisplay.innerText = `Score: ${Math.floor(state.score)}`;
        uiLayer.classList.remove('hidden');
        gameOverScreen.classList.remove('hidden');
    }

    function updatePhysics() {
        // 1. Calculate Raw Tilt (Difference from neutral)
        let rawTilt = state.headTilt - state.neutralTilt;

        // 2. Apply Deadzone (Ignore tiny jitters)
        let netTilt = 0;
        if (Math.abs(rawTilt) > CONFIG.deadzone) {
            netTilt = rawTilt;
        }

        // 3. --- THE FIX: INVERT THE TILT ---
        // Explanation: Left Tilt (Positive Angle) needs to move Left (Negative Screen X).
        // We multiply by -1 to flip the direction.
        let controlTilt = netTilt * -1; 

        // 4. Direct Position Mapping (No Velocity = No Drifting/Stuck)
        // Center of screen
        const centerX = canvas.width / 2;
        
        // Calculate new X position directly
        let targetX = centerX + (controlTilt * CONFIG.sensitivity);

        // 5. Keep ball inside screen
        if (targetX < CONFIG.ballSize) targetX = CONFIG.ballSize;
        if (targetX > canvas.width - CONFIG.ballSize) targetX = canvas.width - CONFIG.ballSize;

        state.ball.x = targetX;

        // Update Debug Info
        dbgRaw.innerText = state.headTilt.toFixed(1);
        dbgNeutral.innerText = state.neutralTilt.toFixed(1);
        dbgTilt.innerText = controlTilt.toFixed(1);
        
        if (controlTilt > 1) {
            dbgDir.innerText = "LEFT <<<<";
            dbgDir.className = "indicator left-arr";
        } else if (controlTilt < -1) {
            dbgDir.innerText = ">>>> RIGHT";
            dbgDir.className = "indicator right-arr";
        } else {
            dbgDir.innerText = "CENTER";
            dbgDir.className = "indicator";
        }

        // Update Walls
        for (let i = state.walls.length - 1; i >= 0; i--) {
            let wall = state.walls[i];
            wall.y -= CONFIG.wallSpeed;
            wall.gapX += wall.gapSpeed * wall.gapDirection;

            if (wall.gapX < CONFIG.gapSize/2 + 50) wall.gapDirection = 1;
            else if (wall.gapX > canvas.width - CONFIG.gapSize/2 - 50) wall.gapDirection = -1;

            if (wall.y < -100) {
                state.walls.splice(i, 1);
                state.score += 100;
            }
        }

        state.frames++;
        if (state.frames % CONFIG.spawnRate === 0) {
            createWall(canvas.height + 100);
        }
    }

    function checkCollisions() {
        const r = CONFIG.ballSize;
        const bx = state.ball.x;
        const by = state.ball.y;

        for (let wall of state.walls) {
            if (by + r > wall.y && by - r < wall.y + wall.height) {
                const gapLeft = wall.gapX - CONFIG.gapSize / 2;
                const gapRight = wall.gapX + CONFIG.gapSize / 2;
                if (bx - r < gapLeft || bx + r > gapRight) {
                    return true;
                }
            }
        }
        return false;
    }

    function draw() {
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Grid
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;
        ctx.beginPath();
        let offset = (state.frames * 2) % 50;
        for(let y = offset; y < canvas.height; y += 50) {
            ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();

        // Walls
        ctx.fillStyle = '#00d2ff';
        ctx.shadowColor = '#00d2ff';
        ctx.shadowBlur = 15;

        for (let wall of state.walls) {
            const gapLeft = wall.gapX - CONFIG.gapSize / 2;
            const gapRight = wall.gapX + CONFIG.gapSize / 2;
            ctx.fillRect(0, wall.y, gapLeft, wall.height);
            ctx.fillRect(gapRight, wall.y, canvas.width - gapRight, wall.height);
        }
        ctx.shadowBlur = 0;

        // Ball
        ctx.beginPath();
        ctx.arc(state.ball.x, state.ball.y, CONFIG.ballSize, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        
        // Ball Glow
        ctx.beginPath();
        ctx.arc(state.ball.x, state.ball.y, CONFIG.ballSize * 1.5, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.stroke();

        // Score
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px Arial';
        ctx.fillText(`SCORE: ${Math.floor(state.score)}`, 30, 50);
    }

    function gameLoop() {
        if (!state.isPlaying) return;

        updatePhysics();

        if (checkCollisions()) {
            draw();
            gameOver();
        } else {
            draw();
            requestAnimationFrame(gameLoop);
        }
    }

    document.getElementById('btn-start').addEventListener('click', startGame);
    document.getElementById('btn-restart').addEventListener('click', startGame);

</script>
</body>
</html>