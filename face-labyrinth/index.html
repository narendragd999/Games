<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Face Tilt: Mobile Optimized</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            color: white;
            touch-action: none; /* Prevent scrolling on mobile */
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background: #0a0a0a;
            width: 100%;
            height: 100%;
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.9);
            z-index: 10;
        }

        .screen {
            background: rgba(20, 30, 40, 0.95);
            padding: 30px;
            border: 2px solid #00d2ff;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 30px #00d2ff;
            width: 80%;
            max-width: 400px;
        }

        h1 { margin: 0 0 15px 0; color: #00d2ff; font-size: 1.5rem; letter-spacing: 1px;}
        p { font-size: 0.9rem; color: #ccc; margin-bottom: 15px; line-height: 1.4; }
        
        button {
            background: #00d2ff;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 15px;
            width: 100%;
        }
        button:active { background: #fff; transform: scale(0.98); }

        #input-video { display: none; }
        .hidden { display: none !important; }

        /* Debug Panel for Mobile */
        #debug-panel {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0,0,0,0.6);
            padding: 5px;
            font-family: monospace;
            font-size: 10px;
            color: #0f0;
            pointer-events: none;
            display: none; /* Hidden by default on mobile to save space */
        }
    </style>
</head>
<body>

    <div id="game-container">
        <video id="input-video"></video>
        <canvas id="game-canvas"></canvas>

        <!-- Debug (Hidden on mobile usually, helpful for testing) -->
        <div id="debug-panel">
            FPS: <span id="dbg-fps">0</span><br>
            TILT: <span id="dbg-tilt">0</span>
        </div>

        <div id="ui-layer">
            <div id="start-screen" class="screen">
                <h1>Mobile Ready</h1>
                <p>Optimized for touchscreens.</p>
                <p><strong>Hold phone vertically.</strong></p>
                <p>Tilt your head Left/Right to move the ball.</p>
                <button id="btn-start">Start Game</button>
            </div>

            <div id="game-over-screen" class="screen hidden">
                <h1 style="color: #ff4444;">CRASHED!</h1>
                <p>Wall impact detected.</p>
                <h2 id="final-score">Score: 0</h2>
                <button id="btn-restart">Try Again</button>
            </div>
            
            <div id="loading-screen" class="screen">
                <h2>Loading AI...</h2>
                <p>Please wait (using Lite Mode for mobile)</p>
            </div>
        </div>
    </div>

<script>
    // --- Configuration ---
    const CONFIG = {
        ballSize: 10, // Slightly smaller for mobile
        sensitivity: 12,       // Pixels per degree
        deadzone: 2.5,         // Ignore jitter
        wallSpeedPercent: 0.008, // NEW: Speed is 0.8% of screen height per frame (Consistent on all devices)
        spawnRate: 60,         // Spawn faster since walls move slower relatively
        gapSizePercent: 0.25,  // Gap is 25% of screen width
        gapSpeedBase: 2
    };

    // --- Game State ---
    const state = {
        isPlaying: false,
        score: 0,
        frames: 0,
        headTilt: 0,
        neutralTilt: 0,
        ball: { x: 0, y: 0 },
        walls: [],
        lastTime: 0
    };

    // --- Elements ---
    const videoElement = document.getElementById('input-video');
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const uiLayer = document.getElementById('ui-layer');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const scoreDisplay = document.getElementById('final-score');
    const loadingScreen = document.getElementById('loading-screen');

    // --- Resize ---
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        state.ball.y = canvas.height - 120; // Adjust ball position for mobile
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // --- MediaPipe Face Mesh Setup (MOBILE OPTIMIZED) ---
    const faceMesh = new FaceMesh({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
    }});

    faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: false, // FALSE: Saves significant CPU on mobile
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
        modelComplexity: 0 // 0=Lite (Essential for mobile), 1=Full
    });

    faceMesh.onResults(onFaceResults);

    // Use lower resolution for camera to save CPU
    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await faceMesh.send({image: videoElement});
        },
        width: 320, // Low res for speed
        height: 240
    });
    
    // Start camera and hide loading when ready
    camera.start()
        .then(() => {
            loadingScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
        })
        .catch(err => {
            console.error("Camera error:", err);
            loadingScreen.innerHTML = "<h2 style='color:red'>Camera Error</h2><p>Please allow camera access.</p>";
        });

    function onFaceResults(results) {
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            const landmarks = results.multiFaceLandmarks[0];
            const leftEye = landmarks[33];
            const rightEye = landmarks[263];
            
            const angle = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x);
            state.headTilt = angle * (180 / Math.PI);
        }
    }

    function calibrateTilt() {
        state.neutralTilt = state.headTilt;
    }

    // --- Game Logic ---

    function startGame() {
        calibrateTilt();
        state.isPlaying = true;
        state.score = 0;
        state.frames = 0;
        state.walls = [];

        uiLayer.classList.add('hidden');
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');

        createWall(canvas.height + 200);
        requestAnimationFrame(gameLoop);
    }

    // Tap screen to recalibrate if needed
    document.addEventListener('click', (e) => {
        if(state.isPlaying && e.target.tagName !== 'BUTTON') {
            calibrateTilt();
        }
    });

    function createWall(yPos) {
        const gapWidth = canvas.width * CONFIG.gapSizePercent;
        const padding = gapWidth;
        const randomX = padding + Math.random() * (canvas.width - padding * 2);
        
        const direction = Math.random() > 0.5 ? 1 : -1;
        const speed = (Math.random() * 1.5) + 0.5; 

        state.walls.push({
            y: yPos,
            gapX: randomX,
            gapDirection: direction,
            gapSpeed: speed,
            height: 30, // Thinner walls for mobile
            gapWidth: gapWidth
        });
    }

    function gameOver() {
        state.isPlaying = false;
        scoreDisplay.innerText = `Score: ${Math.floor(state.score)}`;
        uiLayer.classList.remove('hidden');
        gameOverScreen.classList.remove('hidden');
    }

    function updatePhysics() {
        // 1. Calculate Raw Tilt
        let rawTilt = state.headTilt - state.neutralTilt;

        // 2. Apply Deadzone
        let netTilt = 0;
        if (Math.abs(rawTilt) > CONFIG.deadzone) {
            netTilt = rawTilt;
        }

        // 3. INVERT TILT for correct direction
        let controlTilt = netTilt * -1; 

        // 4. Direct Position Mapping
        const centerX = canvas.width / 2;
        let targetX = centerX + (controlTilt * CONFIG.sensitivity);

        // 5. Bounds
        if (targetX < CONFIG.ballSize) targetX = CONFIG.ballSize;
        if (targetX > canvas.width - CONFIG.ballSize) targetX = canvas.width - CONFIG.ballSize;

        state.ball.x = targetX;

        // 6. Update Walls (Percentage Speed)
        const wallStep = canvas.height * CONFIG.wallSpeedPercent;

        for (let i = state.walls.length - 1; i >= 0; i--) {
            let wall = state.walls[i];
            wall.y -= wallStep;
            
            // Move Gap
            wall.gapX += wall.gapSpeed * wall.gapDirection;

            // Bounce Gap
            if (wall.gapX < wall.gapWidth/2 + 20) wall.gapDirection = 1;
            else if (wall.gapX > canvas.width - wall.gapWidth/2 - 20) wall.gapDirection = -1;

            if (wall.y < -100) {
                state.walls.splice(i, 1);
                state.score += 100;
            }
        }

        state.frames++;
        if (state.frames % CONFIG.spawnRate === 0) {
            createWall(canvas.height + 100);
        }
    }

    function checkCollisions() {
        const r = CONFIG.ballSize;
        const bx = state.ball.x;
        const by = state.ball.y;

        for (let wall of state.walls) {
            if (by + r > wall.y && by - r < wall.y + wall.height) {
                const gapLeft = wall.gapX - wall.gapWidth / 2;
                const gapRight = wall.gapX + wall.gapWidth / 2;
                if (bx - r < gapLeft || bx + r > gapRight) {
                    return true;
                }
            }
        }
        return false;
    }

    function draw() {
        // Clear
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Grid
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.beginPath();
        let offset = (state.frames * (canvas.height * CONFIG.wallSpeedPercent)) % 50;
        for(let y = offset; y < canvas.height; y += 50) {
            ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();

        // Walls
        ctx.fillStyle = '#00d2ff';
        ctx.shadowColor = '#00d2ff';
        ctx.shadowBlur = 10;

        for (let wall of state.walls) {
            const gapLeft = wall.gapX - wall.gapWidth / 2;
            const gapRight = wall.gapX + wall.gapWidth / 2;
            ctx.fillRect(0, wall.y, gapLeft, wall.height);
            ctx.fillRect(gapRight, wall.y, canvas.width - gapRight, wall.height);
        }
        ctx.shadowBlur = 0;

        // Ball
        ctx.beginPath();
        ctx.arc(state.ball.x, state.ball.y, CONFIG.ballSize, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();

        // Score
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px Arial';
        ctx.fillText(`SCORE: ${Math.floor(state.score)}`, 20, 40);
        
        // Mobile FPS / Debug (Optional)
        if(state.frames % 30 === 0) {
             document.getElementById('dbg-fps').innerText = "Running";
             document.getElementById('dbg-tilt').innerText = state.headTilt.toFixed(1);
        }
    }

    function gameLoop() {
        if (!state.isPlaying) return;

        updatePhysics();

        if (checkCollisions()) {
            draw();
            gameOver();
        } else {
            draw();
            requestAnimationFrame(gameLoop);
        }
    }

    document.getElementById('btn-start').addEventListener('click', startGame);
    document.getElementById('btn-restart').addEventListener('click', startGame);

</script>
</body>
</html>