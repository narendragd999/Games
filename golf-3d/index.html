<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zen Golf 3D: Fixed Controls</title>
    <style>
        :root {
            --primary-color: #ffffff;
            --accent-color: #FFD700;
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --font-main: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; touch-action: none; }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1cb5e0 0%, #000851 100%);
            font-family: var(--font-main);
            color: var(--primary-color);
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            justify-content: space-between; padding: 20px;
            z-index: 10;
        }

        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: auto; }

        .stat-box {
            background: var(--glass-bg); backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border); border-radius: 12px;
            padding: 8px 16px; text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .stat-value { font-size: 1.2rem; font-weight: 700; display: block; }
        .stat-label { font-size: 0.7rem; opacity: 0.7; text-transform: uppercase; }

        .icon-btn {
            background: var(--glass-bg); border: 1px solid var(--glass-border);
            border-radius: 50%; width: 44px; height: 44px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; color: white; margin-left: 10px;
            transition: background 0.2s;
        }
        .icon-btn:hover { background: rgba(255,255,255,0.2); }

        #power-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 8px; background: rgba(0,0,0,0.4); border-radius: 4px; overflow: hidden;
            opacity: 0; transition: opacity 0.2s;
        }
        #power-bar { width: 0%; height: 100%; background: #00e5ff; }

        .message {
            position: absolute; top: 20%; width: 100%; text-align: center;
            opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }
        .message h1 { font-size: 2rem; margin: 0; text-shadow: 0 2px 4px rgba(0,0,0,0.5); color: var(--accent-color); }

        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(5px);
            z-index: 100; display: flex; align-items: center; justify-content: center;
            opacity: 1; transition: opacity 0.3s;
        }
        .modal.hidden { opacity: 0; pointer-events: none; }
        .modal-content {
            background: white; color: #333; padding: 30px; border-radius: 20px;
            max-width: 90%; width: 400px; text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .btn {
            background: #1cb5e0; color: white; border: none; padding: 12px 24px;
            border-radius: 25px; font-weight: bold; cursor: pointer; margin-top: 20px;
        }
    </style>
    <!-- Three.js Import -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
        }
      }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div style="display:flex; gap:10px;">
                <div class="stat-box">
                    <span class="stat-value" id="level-display">1</span>
                    <span class="stat-label">Level</span>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="shots-display">0</span>
                    <span class="stat-label">Shots</span>
                </div>
            </div>
            <div>
                <div class="icon-btn" id="reset-btn">â†º</div>
                <div class="icon-btn" id="info-btn">?</div>
            </div>
        </div>
        
        <div class="message" id="message-overlay">
            <h1 id="message-text">NICE SHOT!</h1>
        </div>

        <div id="power-container"><div id="power-bar"></div></div>
    </div>

    <div id="intro-modal" class="modal">
        <div class="modal-content">
            <h2>Zen Golf 3D</h2>
            <p>Drag anywhere on the screen <strong>backwards</strong> to aim and power up. <strong>Release</strong> to shoot.</p>
            <button class="btn" id="start-btn">Play Now</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        // --- Config ---
        const CONFIG = {
            ballRadius: 0.25,
            wallHeight: 0.5,
            maxPower: 15.0, // Units per second
            friction: 2.0,  // Deceleration units per second
            stopThreshold: 0.2,
            colors: {
                grass: 0x56ab2f,
                wall: 0x8d6e63,
                ball: 0xffffff
            }
        };

        // --- State ---
        const state = {
            level: 1,
            shots: 0,
            isDragging: false,
            isMoving: false,
            dragStartPoint: new THREE.Vector3(),
            dragCurrentPoint: new THREE.Vector3(),
            velocity: new THREE.Vector3(),
            clock: new THREE.Clock()
        };

        // --- Audio ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            
            if(type === 'hit') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'win') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.linearRampToValueAtTime(880, now + 0.3);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            }
        }

        // --- Three.js Init ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x1cb5e0, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 15, 10);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        // Expand shadow cam
        dirLight.shadow.camera.left = -10; dirLight.shadow.camera.right = 10;
        dirLight.shadow.camera.top = 10; dirLight.shadow.camera.bottom = -10;
        scene.add(dirLight);

        // Materials
        const matGrass = new THREE.MeshStandardMaterial({ color: CONFIG.colors.grass, roughness: 1 });
        const matWall = new THREE.MeshStandardMaterial({ color: CONFIG.colors.wall, roughness: 0.5 });
        const matBall = new THREE.MeshStandardMaterial({ color: CONFIG.colors.ball, roughness: 0.2, metalness: 0.1 });

        // --- Objects ---
        let ball, hole, aimLine;
        const walls = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // Ground plane for raycasting

        function createLevel() {
            // Clear old
            walls.forEach(w => scene.remove(w));
            walls.length = 0;
            if(ball) scene.remove(ball);
            if(hole) scene.remove(hole);
            if(aimLine) scene.remove(aimLine);

            // Base
            const base = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 10), matGrass);
            base.position.y = -0.5;
            base.receiveShadow = true;
            scene.add(base);

            // Procedural walls
            const layout = [];
            // Simple generation logic
            const numWalls = Math.min(state.level + 2, 8);
            for(let i=0; i<numWalls; i++) {
                const w = Math.random() > 0.5 ? 3 : 0.5;
                const d = Math.random() > 0.5 ? 0.5 : 3;
                const x = (Math.random() * 8) - 4;
                const z = (Math.random() * 6) - 3; // Bias towards top half
                if (Math.abs(x) < 1.5 && z > 2) continue; // Don't block start
                
                const geo = new RoundedBoxGeometry(w, CONFIG.wallHeight, d, 4, 0.1);
                const wall = new THREE.Mesh(geo, matWall);
                wall.position.set(x, CONFIG.wallHeight/2, z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                // Bounding box for physics
                wall.userData = {
                    minX: x - w/2, maxX: x + w/2,
                    minZ: z - d/2, maxZ: z + d/2
                };
                scene.add(wall);
                walls.push(wall);
            }

            // Ball
            ball = new THREE.Mesh(new THREE.SphereGeometry(CONFIG.ballRadius, 32, 32), matBall);
            ball.position.set(0, CONFIG.ballRadius, 4);
            ball.castShadow = true;
            scene.add(ball);

            // Hole
            hole = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.1), new THREE.MeshBasicMaterial({color:0x000000}));
            hole.position.set((Math.random()*4)-2, 0.05, -4);
            scene.add(hole);

            // Aim Line
            aimLine = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,1)]),
                new THREE.LineBasicMaterial({color: 0xffffff, transparent:true, opacity:0.6, linewidth: 2})
            );
            scene.add(aimLine);
            aimLine.visible = false;

            state.shots = 0;
            state.velocity.set(0,0,0);
            state.isMoving = false;
            updateUI();
            
            // Snap camera initially
            camera.position.set(0, 15, 10); 
            camera.lookAt(0,0,0);
        }

        // --- Input Handling (Raycasting) ---
        function getIntersection(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            return target;
        }

        function onDown(e) {
            if (state.isMoving || state.level > 99) return; // Safety
            e.preventDefault();
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            
            const point = getIntersection(clientX, clientY);
            if (point) {
                state.isDragging = true;
                state.dragStartPoint.copy(point);
                state.dragCurrentPoint.copy(point);
                document.getElementById('power-container').style.opacity = 1;
            }
        }

        function onMove(e) {
            if (!state.isDragging) return;
            e.preventDefault(); // Stop scroll
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            
            const point = getIntersection(clientX, clientY);
            if (point) {
                state.dragCurrentPoint.copy(point);
                updateAimVisuals();
            }
        }

        function onUp(e) {
            if (!state.isDragging) return;
            state.isDragging = false;
            document.getElementById('power-container').style.opacity = 0;
            aimLine.visible = false;

            // Calculate Vector
            const dx = state.dragStartPoint.x - state.dragCurrentPoint.x;
            const dz = state.dragStartPoint.z - state.dragCurrentPoint.z;
            const dist = Math.sqrt(dx*dx + dz*dz);

            // 1 unit drag = 1 unit power roughly, scaled
            // If dragged > 0.5 units, shoot
            if (dist > 0.5) {
                const power = Math.min(dist * 1.5, CONFIG.maxPower); // Scale factor
                const angle = Math.atan2(dz, dx);
                
                state.velocity.x = Math.cos(angle) * power;
                state.velocity.z = Math.sin(angle) * power;
                
                state.isMoving = true;
                state.shots++;
                updateUI();
                playSound('hit');
            }
        }

        function updateAimVisuals() {
            // Draw line from ball in direction of pull-back
            // Vector: Start -> Current (Pull direction)
            // Shot direction: Opposite
            
            const diff = new THREE.Vector3().subVectors(state.dragStartPoint, state.dragCurrentPoint);
            // Cap visual length
            if (diff.length() > 4) diff.normalize().multiplyScalar(4);
            
            aimLine.position.copy(ball.position);
            aimLine.lookAt(ball.position.clone().add(diff));
            aimLine.scale.z = diff.length(); // Line is created along Z
            aimLine.visible = true;

            // Update UI Bar
            const pct = Math.min(diff.length() / 4, 1);
            document.getElementById('power-bar').style.width = (pct * 100) + '%';
            document.getElementById('power-bar').style.backgroundColor = `hsl(${120 - pct*120}, 100%, 50%)`;
        }

        // --- Physics ---
        function updatePhysics(dt) {
            if (!state.isMoving) return;

            // Move ball
            ball.position.addScaledVector(state.velocity, dt);
            
            // Rotation
            ball.rotation.x -= state.velocity.z * dt;
            ball.rotation.z += state.velocity.x * dt;

            // Friction
            const speed = state.velocity.length();
            if (speed > 0) {
                const drop = CONFIG.friction * dt;
                const newSpeed = Math.max(0, speed - drop);
                state.velocity.multiplyScalar(newSpeed / speed);
            }

            // Stop check
            if (state.velocity.length() < CONFIG.stopThreshold) {
                state.velocity.set(0,0,0);
                state.isMoving = false;
                checkHole();
            }

            // Wall Collision
            walls.forEach(w => {
                const d = w.userData;
                const b = ball.position;
                const r = CONFIG.ballRadius;

                // Simple AABB check
                if (b.x + r > d.minX && b.x - r < d.maxX && b.z + r > d.minZ && b.z - r < d.maxZ) {
                    // Find nearest edge
                    const overlapLeft = (b.x + r) - d.minX;
                    const overlapRight = d.maxX - (b.x - r);
                    const overlapTop = (b.z + r) - d.minZ;
                    const overlapBottom = d.maxZ - (b.z - r);

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    if (minOverlap === overlapLeft) { b.x = d.minX - r; state.velocity.x *= -0.8; }
                    else if (minOverlap === overlapRight) { b.x = d.maxX + r; state.velocity.x *= -0.8; }
                    else if (minOverlap === overlapTop) { b.z = d.minZ - r; state.velocity.z *= -0.8; }
                    else if (minOverlap === overlapBottom) { b.z = d.maxZ + r; state.velocity.z *= -0.8; }
                }
            });

            // Bounds
            if (ball.position.length() > 6) {
                // Out of bounds - reset
                state.isMoving = false;
                state.velocity.set(0,0,0);
                ball.position.set(0, CONFIG.ballRadius, 4);
                // Flash red or something?
            }

            // Hole check (while moving for "suck" effect)
            const distHole = ball.position.distanceTo(hole.position);
            if (distHole < 0.4 && state.velocity.length() < 8) {
                // Suck in
                ball.position.lerp(hole.position, 0.2);
                state.velocity.multiplyScalar(0.8);
                if(distHole < 0.1) {
                    state.isMoving = false;
                    winLevel();
                }
            }
        }

        function checkHole() {
             const dist = ball.position.distanceTo(hole.position);
             if (dist < 0.3) winLevel();
        }

        function winLevel() {
            if (ball.position.y < -1) return; // already won
            ball.position.y = -1; // hide
            playSound('win');
            
            const msg = document.getElementById('message-overlay');
            const txt = document.getElementById('message-text');
            txt.innerText = state.shots === 1 ? "HOLE IN ONE!" : "LEVEL COMPLETE";
            msg.style.opacity = 1;

            setTimeout(() => {
                state.level++;
                createLevel();
                msg.style.opacity = 0;
            }, 2000);
        }

        function updateCamera() {
            // Smooth follow
            const targetPos = ball.position.clone().add(new THREE.Vector3(0, 15, 10));
            // If dragging, don't move camera (prevents motion sickness)
            if(!state.isDragging) {
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(ball.position);
            }
        }

        function updateUI() {
            document.getElementById('level-display').innerText = state.level;
            document.getElementById('shots-display').innerText = state.shots;
        }

        // --- Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(state.clock.getDelta(), 0.1); // Cap dt
            updatePhysics(dt);
            updateCamera();
            renderer.render(scene, camera);
        }

        // --- Events ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        
        window.addEventListener('touchstart', onDown, {passive: false});
        window.addEventListener('touchmove', onMove, {passive: false});
        window.addEventListener('touchend', onUp);

        document.getElementById('reset-btn').onclick = () => createLevel();
        document.getElementById('start-btn').onclick = () => {
            document.getElementById('intro-modal').classList.add('hidden');
            createLevel();
            animate();
        };

    </script>
</body>
</html>